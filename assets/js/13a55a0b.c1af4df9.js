"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[7457],{61503(n,i,e){e.r(i),e.d(i,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver","title":"Ottimizzazione binaria di ordine superiore con l\'Optimization Solver di Q-CTRL","description":"Risolvere un problema di ottimizzazione quantistica su scala di utilit\xe0 utilizzando l\'Optimization Solver, una Qiskit Function di Q-CTRL Fire Opal","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver.mdx","sourceDirName":"tutorials","slug":"/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver","permalink":"/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver.mdx","tags":[],"version":"current","frontMatter":{"title":"Ottimizzazione binaria di ordine superiore con l\'Optimization Solver di Q-CTRL","sidebar_label":"Ottimizzazione binaria di ordine superiore con l\'Optimization Solver di Q-CTRL","description":"Risolvere un problema di ottimizzazione quantistica su scala di utilit\xe0 utilizzando l\'Optimization Solver, una Qiskit Function di Q-CTRL Fire Opal","notebook_path":"docs/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Mitigazione degli errori con la funzione IBM Circuit","permalink":"/tutorials/error-mitigation-with-qiskit-functions"},"next":{"title":"Modellare un fluido non viscoso in movimento usando QUICK-PDE","permalink":"/tutorials/colibritd-pde"}}');var o=e(74848),x=e(28453);const a={title:"Ottimizzazione binaria di ordine superiore con l'Optimization Solver di Q-CTRL",sidebar_label:"Ottimizzazione binaria di ordine superiore con l'Optimization Solver di Q-CTRL",description:"Risolvere un problema di ottimizzazione quantistica su scala di utilit\xe0 utilizzando l'Optimization Solver, una Qiskit Function di Q-CTRL Fire Opal",notebook_path:"docs/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver.ipynb"},r=void 0,s={},l=[{value:"Contesto",id:"background",level:2},{value:"Requisiti",id:"requirements",level:2},{value:"Configurazione",id:"setup",level:2},{value:"Passaggio 1: Definire il problema come una funzione obiettivo",id:"step-1-define-the-problem-as-an-objective-function",level:2},{value:"Step 2: Eseguire l&#39;algoritmo ibrido utilizzando il Fire Opal Optimization Solver",id:"step-2-run-the-hybrid-algorithm-using-the-fire-opal-optimization-solver",level:2},{value:"Step 3: Valutare i risultati",id:"step-3-evaluate-results",level:2}];function c(n){const i={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,x.R)(),...n.components},{Admonition:t,OpenInLabBanner:a}=i;return t||u("Admonition",!0),a||u("OpenInLabBanner",!0),(0,o.jsxs)(o.Fragment,{children:["\n",(0,o.jsx)(a,{notebookPath:"docs/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver.ipynb"}),"\n","\n",(0,o.jsx)(t,{type:"note",title:"Nota",children:(0,o.jsx)(i.p,{children:"Le Qiskit Functions sono una funzionalit\xe0 sperimentale disponibile solo per gli utenti dei piani IBM Quantum\xae Premium Plan, Flex Plan e On-Prem (tramite IBM Quantum Platform API) Plan. Sono in stato di rilascio di anteprima e soggette a modifiche."})}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.em,{children:"Stima di utilizzo: 24 minuti su un processore Heron r2. (NOTA: questa \xe8 solo una stima. Il tempo di esecuzione effettivo potrebbe variare.)"})}),"\n",(0,o.jsx)(i.h2,{id:"background",children:"Contesto"}),"\n",(0,o.jsxs)(i.p,{children:["Questo tutorial dimostra come risolvere un problema di ottimizzazione binaria di ordine superiore (HOBO) utilizzando l'",(0,o.jsx)(i.a,{href:"/guides/q-ctrl-optimization-solver",children:"Optimization Solver, una Qiskit Function di Q-CTRL Fire Opal"}),". L'esempio presentato in questo tutorial \xe8 un problema di ottimizzazione progettato per trovare l'energia dello stato fondamentale di un modello di Ising a 156 qubit con legami casuali contenente termini cubici. L'Optimization Solver pu\xf2 essere utilizzato per problemi di ottimizzazione generali che possono essere definiti come una funzione obiettivo."]}),"\n",(0,o.jsxs)(i.p,{children:["L'Optimization Solver automatizza completamente i passaggi di implementazione hardware-aware per risolvere problemi di ottimizzazione su hardware quantistico e, sfruttando il ",(0,o.jsx)(i.a,{href:"/guides/q-ctrl-performance-management",children:"Performance Management"})," per l'esecuzione quantistica, ottiene soluzioni accurate su scala di utilit\xe0. Per un riepilogo dettagliato del flusso di lavoro completo dell'Optimization Solver e dei risultati di benchmarking, fate riferimento al ",(0,o.jsx)(i.a,{href:"https://arxiv.org/abs/2406.01743",children:"manoscritto pubblicato"}),"."]}),"\n",(0,o.jsx)(i.p,{children:"Questo tutorial illustra i seguenti passaggi:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Definire il problema come una funzione obiettivo"}),"\n",(0,o.jsx)(i.li,{children:"Eseguire l'algoritmo ibrido utilizzando il Fire Opal Optimization Solver"}),"\n",(0,o.jsx)(i.li,{children:"Valutare i risultati"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"requirements",children:"Requisiti"}),"\n",(0,o.jsx)(i.p,{children:"Prima di iniziare questo tutorial, assicuratevi di avere installato quanto segue:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Qiskit Functions (",(0,o.jsx)(i.code,{children:"pip install qiskit-ibm-catalog"}),")"]}),"\n",(0,o.jsxs)(i.li,{children:["SymPy (",(0,o.jsx)(i.code,{children:"pip install sympy"}),")"]}),"\n"]}),"\n",(0,o.jsxs)(i.p,{children:["Dovrete anche ottenere l'accesso alla funzione Optimization Solver. ",(0,o.jsx)(i.a,{href:"https://quantum.cloud.ibm.com/functions?id=q-ctrl-optimization-solver",children:"Compilate il modulo"})," per richiedere l'accesso."]}),"\n",(0,o.jsx)(i.h2,{id:"setup",children:"Configurazione"}),"\n",(0,o.jsx)(i.p,{children:"Per prima cosa, importate i pacchetti e gli strumenti necessari."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"# Qiskit Functions Catalog\nfrom qiskit_ibm_catalog import QiskitFunctionsCatalog\n\n# SymPy tools for constructing objective function\nfrom sympy import Poly\nfrom sympy import symbols, srepr\n\n# Tools for plotting and evaluating results\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sympy import lambdify\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Definite le vostre credenziali della ",(0,o.jsx)(i.a,{href:"https://quantum.cloud.ibm.com/",children:"IBM Quantum Platform"}),", che saranno utilizzate durante tutto il tutorial per autenticarsi su Qiskit Runtime e Qiskit Functions."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Credentials\ntoken = "<YOUR-API_KEY>"  # Use the 44-characters API_KEY you have created and saved from the IBM Quantum Platform Home dashboard\ninstance = "<YOUR_CRN>"\n'})}),"\n",(0,o.jsx)(i.h2,{id:"step-1-define-the-problem-as-an-objective-function",children:"Passaggio 1: Definire il problema come una funzione obiettivo"}),"\n",(0,o.jsx)(i.p,{children:"L'Optimization Solver accetta come input una funzione obiettivo o un grafo. In questo tutorial, il problema di minimizzazione dello spin glass di Ising \xe8 definito come una funzione obiettivo ed \xe8 stato adattato alla topologia heavy-hex dei dispositivi IBM\xae."}),"\n",(0,o.jsx)(i.p,{children:"Poich\xe9 questa funzione obiettivo contiene termini cubici, quadratici e lineari, rientra nella classe dei problemi HOBO, notoriamente molto pi\xf9 complicati da risolvere rispetto ai problemi convenzionali di ottimizzazione binaria non vincolata quadratica (QUBO)."}),"\n",(0,o.jsxs)(i.p,{children:["Per una discussione dettagliata sulla costruzione della definizione del problema e sui risultati precedenti ottenuti dall'Optimization Solver, fate riferimento a ",(0,o.jsx)(i.a,{href:"https://arxiv.org/abs/2406.01743",children:"questo manoscritto tecnico"}),". Il problema \xe8 stato originariamente definito e valutato come parte di un ",(0,o.jsx)(i.a,{href:"https://arxiv.org/abs/2312.00997",children:"articolo pubblicato dal Los Alamos National Laboratory"})," ed \xe8 stato adattato per sfruttare l'intera larghezza del dispositivo dei processori IBM Quantum Heron a 156 qubit."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'qubit_count = 156\n\n# Create symbolic variables to represent qubits\nx = symbols([f"x[{i}]" for i in range(qubit_count)])\n\n# # Define a polynomial representing a spin glass model\nspin_glass_poly = Poly(\n    -4 * x[0] * x[1]\n    - 8 * x[1] * x[2] * x[3]\n    + 8 * x[1] * x[2]\n    + 4 * x[1] * x[3]\n    - 4 * x[2]\n    + 8 * x[3] * x[4] * x[5]\n    - 4 * x[3] * x[5]\n    - 8 * x[3] * x[16] * x[23]\n    + 4 * x[3] * x[23]\n    - 2 * x[3]\n    - 4 * x[4]\n    - 8 * x[5] * x[6] * x[7]\n    + 8 * x[5] * x[6]\n    + 4 * x[5] * x[7]\n    - 2 * x[5]\n    + 8 * x[6] * x[7]\n    - 4 * x[6]\n    - 8 * x[7] * x[8] * x[9]\n    + 4 * x[7] * x[9]\n    - 8 * x[7] * x[17] * x[27]\n    + 4 * x[7] * x[27]\n    - 6 * x[7]\n    + 8 * x[8] * x[9]\n    + 8 * x[9] * x[10] * x[11]\n    - 4 * x[9] * x[11]\n    - 2 * x[9]\n    - 8 * x[10] * x[11]\n    + 4 * x[10]\n    - 8 * x[11] * x[12] * x[13]\n    + 4 * x[11] * x[13]\n    - 8 * x[11] * x[18] * x[31]\n    + 8 * x[11] * x[18]\n    + 4 * x[11] * x[31]\n    - 2 * x[11]\n    + 8 * x[12] * x[13]\n    + 8 * x[13] * x[14] * x[15]\n    - 4 * x[13] * x[15]\n    - 2 * x[13]\n    - 8 * x[14] * x[15]\n    + 4 * x[14]\n    - 8 * x[15] * x[19] * x[35]\n    + 8 * x[15] * x[19]\n    + 4 * x[15] * x[35]\n    - 2 * x[15]\n    + 8 * x[16] * x[23]\n    + 8 * x[17] * x[27]\n    - 4 * x[17]\n    + 8 * x[18] * x[31]\n    - 8 * x[18]\n    + 8 * x[19] * x[35]\n    - 8 * x[19]\n    + 4 * x[20] * x[21]\n    - 4 * x[20]\n    - 8 * x[21] * x[22] * x[23]\n    + 8 * x[21] * x[22]\n    + 4 * x[21] * x[23]\n    - 8 * x[21] * x[36] * x[41]\n    + 4 * x[21] * x[41]\n    - 4 * x[21]\n    + 8 * x[22] * x[23]\n    - 8 * x[22]\n    + 8 * x[23] * x[24] * x[25]\n    - 4 * x[23] * x[25]\n    - 10 * x[23]\n    - 8 * x[24] * x[25]\n    + 8 * x[25] * x[26] * x[27]\n    - 8 * x[25] * x[26]\n    - 4 * x[25] * x[27]\n    + 8 * x[25] * x[37] * x[45]\n    - 8 * x[25] * x[37]\n    - 4 * x[25] * x[45]\n    + 14 * x[25]\n    - 8 * x[26] * x[27]\n    + 4 * x[26]\n    + 8 * x[27] * x[28] * x[29]\n    - 4 * x[27] * x[29]\n    - 2 * x[27]\n    - 8 * x[28] * x[29]\n    - 8 * x[29] * x[30] * x[31]\n    + 4 * x[29] * x[31]\n    + 8 * x[29] * x[38] * x[49]\n    - 8 * x[29] * x[38]\n    - 4 * x[29] * x[49]\n    + 6 * x[29]\n    + 8 * x[30] * x[31]\n    - 4 * x[30]\n    - 8 * x[31] * x[32] * x[33]\n    + 4 * x[31] * x[33]\n    - 6 * x[31]\n    + 8 * x[33] * x[34] * x[35]\n    - 4 * x[33] * x[35]\n    - 8 * x[33] * x[39] * x[53]\n    + 8 * x[33] * x[39]\n    + 4 * x[33] * x[53]\n    - 6 * x[33]\n    - 8 * x[34] * x[35]\n    + 2 * x[35]\n    + 8 * x[36] * x[41]\n    - 8 * x[37] * x[45]\n    + 4 * x[37]\n    - 8 * x[38] * x[49]\n    + 4 * x[38]\n    + 4 * x[40] * x[41]\n    - 8 * x[41] * x[42] * x[43]\n    + 4 * x[41] * x[43]\n    - 8 * x[41]\n    + 8 * x[42] * x[43]\n    - 4 * x[42]\n    - 8 * x[43] * x[44] * x[45]\n    + 8 * x[43] * x[44]\n    + 4 * x[43] * x[45]\n    - 8 * x[43] * x[56] * x[63]\n    + 4 * x[43] * x[63]\n    - 6 * x[43]\n    - 4 * x[44]\n    - 8 * x[45] * x[46] * x[47]\n    + 4 * x[45] * x[47]\n    + 2 * x[45]\n    + 4 * x[46]\n    - 8 * x[47] * x[48] * x[49]\n    + 8 * x[47] * x[48]\n    + 4 * x[47] * x[49]\n    - 8 * x[47] * x[57] * x[67]\n    + 4 * x[47] * x[67]\n    - 2 * x[47]\n    - 4 * x[48]\n    - 8 * x[49] * x[50] * x[51]\n    + 8 * x[49] * x[50]\n    + 4 * x[49] * x[51]\n    - 2 * x[49]\n    + 8 * x[50] * x[51]\n    - 8 * x[50]\n    - 8 * x[51] * x[52] * x[53]\n    + 8 * x[51] * x[52]\n    + 4 * x[51] * x[53]\n    - 8 * x[51] * x[58] * x[71]\n    + 4 * x[51] * x[71]\n    - 6 * x[51]\n    + 8 * x[52] * x[53]\n    - 8 * x[52]\n    + 8 * x[53] * x[54] * x[55]\n    - 8 * x[53] * x[54]\n    - 4 * x[53] * x[55]\n    - 2 * x[53]\n    + 4 * x[54]\n    - 8 * x[55] * x[59] * x[75]\n    + 4 * x[55] * x[75]\n    - 2 * x[55]\n    + 8 * x[56] * x[63]\n    + 8 * x[57] * x[67]\n    - 4 * x[57]\n    + 8 * x[58] * x[71]\n    + 8 * x[59] * x[75]\n    - 4 * x[59]\n    + 4 * x[60] * x[61]\n    + 8 * x[61] * x[62] * x[63]\n    - 4 * x[61] * x[63]\n    + 8 * x[61] * x[76] * x[81]\n    - 8 * x[61] * x[76]\n    - 4 * x[61] * x[81]\n    - 8 * x[63] * x[64] * x[65]\n    + 8 * x[63] * x[64]\n    + 4 * x[63] * x[65]\n    - 6 * x[63]\n    + 8 * x[65] * x[66] * x[67]\n    - 8 * x[65] * x[66]\n    - 4 * x[65] * x[67]\n    - 8 * x[65] * x[77] * x[85]\n    + 4 * x[65] * x[85]\n    + 2 * x[65]\n    + 4 * x[66]\n    - 8 * x[67] * x[68] * x[69]\n    + 8 * x[67] * x[68]\n    + 4 * x[67] * x[69]\n    - 10 * x[67]\n    + 8 * x[68] * x[69]\n    - 4 * x[68]\n    + 8 * x[69] * x[70] * x[71]\n    - 4 * x[69] * x[71]\n    - 8 * x[69] * x[78] * x[89]\n    + 4 * x[69] * x[89]\n    - 6 * x[69]\n    + 8 * x[71] * x[72] * x[73]\n    - 8 * x[71] * x[72]\n    - 4 * x[71] * x[73]\n    + 2 * x[71]\n    - 8 * x[72] * x[73]\n    + 8 * x[72]\n    - 8 * x[73] * x[74] * x[75]\n    + 8 * x[73] * x[74]\n    + 4 * x[73] * x[75]\n    - 8 * x[73] * x[79] * x[93]\n    + 8 * x[73] * x[79]\n    + 4 * x[73] * x[93]\n    - 6 * x[73]\n    + 8 * x[74] * x[75]\n    - 4 * x[74]\n    - 10 * x[75]\n    + 4 * x[76]\n    + 8 * x[78] * x[89]\n    - 4 * x[78]\n    - 4 * x[79]\n    - 4 * x[80] * x[81]\n    + 4 * x[80]\n    - 8 * x[81] * x[82] * x[83]\n    + 8 * x[81] * x[82]\n    + 4 * x[81] * x[83]\n    + 8 * x[82] * x[83]\n    - 8 * x[82]\n    - 8 * x[83] * x[84] * x[85]\n    + 4 * x[83] * x[85]\n    - 8 * x[83] * x[96] * x[103]\n    + 4 * x[83] * x[103]\n    - 2 * x[83]\n    - 8 * x[85] * x[86] * x[87]\n    + 8 * x[85] * x[86]\n    + 4 * x[85] * x[87]\n    - 6 * x[85]\n    + 8 * x[86] * x[87]\n    - 4 * x[86]\n    - 8 * x[87] * x[88] * x[89]\n    + 4 * x[87] * x[89]\n    + 8 * x[87] * x[97] * x[107]\n    - 8 * x[87] * x[97]\n    - 4 * x[87] * x[107]\n    + 2 * x[87]\n    + 4 * x[88]\n    - 8 * x[89] * x[90] * x[91]\n    + 8 * x[89] * x[90]\n    + 4 * x[89] * x[91]\n    - 10 * x[89]\n    + 8 * x[90] * x[91]\n    - 8 * x[90]\n    - 8 * x[91] * x[92] * x[93]\n    + 4 * x[91] * x[93]\n    - 8 * x[91] * x[98] * x[111]\n    + 8 * x[91] * x[98]\n    + 4 * x[91] * x[111]\n    - 10 * x[91]\n    + 8 * x[92] * x[93]\n    - 4 * x[92]\n    - 8 * x[93] * x[94] * x[95]\n    + 4 * x[93] * x[95]\n    - 6 * x[93]\n    + 8 * x[95] * x[99] * x[115]\n    - 8 * x[95] * x[99]\n    - 4 * x[95] * x[115]\n    + 2 * x[95]\n    + 4 * x[96]\n    - 8 * x[97] * x[107]\n    + 4 * x[97]\n    - 4 * x[98]\n    - 8 * x[99] * x[115]\n    + 4 * x[99]\n    - 4 * x[100] * x[101]\n    + 8 * x[101] * x[102] * x[103]\n    - 8 * x[101] * x[102]\n    - 4 * x[101] * x[103]\n    - 8 * x[101] * x[116] * x[121]\n    + 8 * x[101] * x[116]\n    + 4 * x[101] * x[121]\n    + 4 * x[101]\n    - 8 * x[103] * x[104] * x[105]\n    + 4 * x[103] * x[105]\n    + 2 * x[103]\n    + 8 * x[105] * x[106] * x[107]\n    - 4 * x[105] * x[107]\n    - 8 * x[105] * x[117] * x[125]\n    + 4 * x[105] * x[125]\n    + 2 * x[105]\n    - 8 * x[106] * x[107]\n    + 4 * x[106]\n    + 8 * x[107] * x[108] * x[109]\n    - 4 * x[107] * x[109]\n    + 6 * x[107]\n    - 4 * x[108]\n    + 8 * x[109] * x[110] * x[111]\n    - 4 * x[109] * x[111]\n    - 8 * x[109] * x[118] * x[129]\n    + 4 * x[109] * x[129]\n    + 2 * x[109]\n    - 8 * x[110] * x[111]\n    + 4 * x[110]\n    - 8 * x[111] * x[112] * x[113]\n    + 8 * x[111] * x[112]\n    + 4 * x[111] * x[113]\n    + 2 * x[111]\n    + 8 * x[112] * x[113]\n    - 8 * x[112]\n    - 8 * x[113] * x[114] * x[115]\n    + 4 * x[113] * x[115]\n    - 8 * x[113] * x[119] * x[133]\n    + 4 * x[113] * x[133]\n    - 2 * x[113]\n    + 6 * x[115]\n    - 4 * x[116]\n    + 4 * x[118]\n    + 4 * x[119]\n    + 4 * x[120] * x[121]\n    - 8 * x[121] * x[122] * x[123]\n    + 4 * x[121] * x[123]\n    - 4 * x[121]\n    + 4 * x[122]\n    - 8 * x[123] * x[124] * x[125]\n    + 4 * x[123] * x[125]\n    - 8 * x[123] * x[136] * x[143]\n    + 4 * x[123] * x[143]\n    - 2 * x[123]\n    + 8 * x[124] * x[125]\n    - 4 * x[124]\n    + 8 * x[125] * x[126] * x[127]\n    - 8 * x[125] * x[126]\n    - 4 * x[125] * x[127]\n    + 2 * x[125]\n    - 8 * x[127] * x[128] * x[129]\n    + 8 * x[127] * x[128]\n    + 4 * x[127] * x[129]\n    + 8 * x[127] * x[137] * x[147]\n    - 8 * x[127] * x[137]\n    - 4 * x[127] * x[147]\n    - 2 * x[127]\n    + 8 * x[129] * x[130] * x[131]\n    - 4 * x[129] * x[131]\n    + 2 * x[129]\n    - 4 * x[130]\n    - 8 * x[131] * x[132] * x[133]\n    + 4 * x[131] * x[133]\n    - 8 * x[131] * x[138] * x[151]\n    + 4 * x[131] * x[151]\n    - 2 * x[131]\n    + 8 * x[133] * x[134] * x[135]\n    - 4 * x[133] * x[135]\n    + 2 * x[133]\n    - 8 * x[134] * x[135]\n    + 4 * x[134]\n    - 8 * x[135] * x[139] * x[155]\n    + 8 * x[135] * x[139]\n    + 4 * x[135] * x[155]\n    + 2 * x[135]\n    + 8 * x[136] * x[143]\n    - 4 * x[136]\n    + 4 * x[138]\n    + 8 * x[139] * x[155]\n    - 4 * x[139]\n    - 4 * x[140] * x[141]\n    - 8 * x[141] * x[142] * x[143]\n    + 8 * x[141] * x[142]\n    + 4 * x[141] * x[143]\n    + 8 * x[142] * x[143]\n    - 8 * x[142]\n    - 8 * x[143] * x[144] * x[145]\n    + 8 * x[143] * x[144]\n    + 4 * x[143] * x[145]\n    - 14 * x[143]\n    + 8 * x[144] * x[145]\n    - 8 * x[144]\n    - 8 * x[145] * x[146] * x[147]\n    + 8 * x[145] * x[146]\n    + 4 * x[145] * x[147]\n    - 6 * x[145]\n    + 8 * x[146] * x[147]\n    - 4 * x[146]\n    - 8 * x[147] * x[148] * x[149]\n    + 8 * x[147] * x[148]\n    + 4 * x[147] * x[149]\n    - 6 * x[147]\n    - 4 * x[148]\n    - 8 * x[149] * x[150] * x[151]\n    + 8 * x[149] * x[150]\n    + 4 * x[149] * x[151]\n    - 6 * x[149]\n    + 8 * x[151] * x[152] * x[153]\n    - 4 * x[151] * x[153]\n    + 2 * x[151]\n    + 8 * x[153] * x[154] * x[155]\n    - 8 * x[153] * x[154]\n    - 4 * x[153] * x[155]\n    + 2 * x[153]\n    - 8 * x[154] * x[155]\n    + 4 * x[154]\n    - 2 * x[155]\n    + 46,\n    x,\n    domain="ZZ",\n)\n'})}),"\n",(0,o.jsx)(i.h2,{id:"step-2-run-the-hybrid-algorithm-using-the-fire-opal-optimization-solver",children:"Step 2: Eseguire l'algoritmo ibrido utilizzando il Fire Opal Optimization Solver"}),"\n",(0,o.jsx)(i.p,{children:"Ora utilizzate l'Optimization Solver Qiskit Function per eseguire l'algoritmo. Dietro le quinte, l'Optimization Solver si occupa di mappare il problema su un algoritmo quantistico ibrido, eseguire i circuiti quantistici con soppressione degli errori ed effettuare l'ottimizzazione classica."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Authenticate to the Qiskit Functions Catalog\ncatalog = QiskitFunctionsCatalog(\n    token=token,\n    instance=instance,\n)\n\n# Load the function\nsolver = catalog.load("q-ctrl/optimization_solver")\n'})}),"\n",(0,o.jsx)(i.p,{children:"Verificate che il dispositivo scelto abbia almeno 156 qubit."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Specify the target backend name\nbackend_name = "<CHOOSE_A_BACKEND>"\n'})}),"\n",(0,o.jsx)(i.p,{children:"Il Solver accetta una rappresentazione in formato stringa della funzione obiettivo."}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"# Convert the objective function to string format\nspin_glass_poly_as_str = srepr(spin_glass_poly)\n"})}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Run the problem\nspin_glass_job = solver.run(\n    problem=spin_glass_poly_as_str,\n    run_options={"backend_name": backend_name},\n)\n'})}),"\n",(0,o.jsxs)(i.p,{children:["Potete utilizzare le familiari ",(0,o.jsx)(i.a,{href:"/guides/serverless",children:"API Qiskit Serverless"})," per verificare lo stato del vostro carico di lavoro Qiskit Function:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"# Get job status\nspin_glass_job.status()\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Il Solver restituisce un dizionario con la soluzione e i metadati associati, come la stringa di bit della soluzione, il numero di iterazioni e la mappatura delle variabili alla stringa di bit. Per una definizione completa degli input e degli output del Solver, consultate la ",(0,o.jsx)(i.a,{href:"",children:"documentazione"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"# Poll for results\nresult = spin_glass_job.result()\n"})}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Get the final bitstring distribution and set the number of shots\ndistribution = result["final_bitstring_distribution"]\n'})}),"\n",(0,o.jsx)(i.h2,{id:"step-3-evaluate-results",children:"Step 3: Valutare i risultati"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Get the solution ground state energy\nprint(f"Minimum ground state energy: {result["solution_bitstring_cost"]}")\n'})}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-text",children:"Minimum ground state energy: -242.0\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Il Solver ha trovato la soluzione corretta, che \xe8 stata validata utilizzando software di ottimizzazione classico. La complessit\xe0 di questo problema su scala utility richiede un software di ottimizzazione avanzato per essere risolto classicamente, come ",(0,o.jsx)(i.a,{href:"https://www.ibm.com/products/ilog-cplex-optimization-studio",children:"IBM ILOG CPLEX Optimization Studio (CPLEX)"})," o ",(0,o.jsx)(i.a,{href:"https://www.gurobi.com/",children:"Gurobi Optimization"}),".\nCome analisi visiva della qualit\xe0 dei risultati, potete rappresentare graficamente i risultati calcolando i valori di costo dalle stringhe di bit e le loro probabilit\xe0. Per confronto, rappresentate i risultati insieme a una distribuzione di stringhe di bit campionate casualmente, che equivale a una soluzione classica \"a forza bruta\". Se l'algoritmo trova consistentemente costi inferiori, ci\xf2 suggerisce che l'algoritmo quantistico sta risolvendo efficacemente il problema di ottimizzazione."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'def plot_cost_histogram(\n    costs, probabilities, distribution, qubit_count, bitstring_cost\n):\n    """Plots a histogram comparing the cost distributions of Q-CTRL Solver and random sampling."""\n\n    # Set figure DPI for higher resolution and font size for labels\n    plt.rcParams["figure.dpi"] = 300\n    plt.rcParams.update({"font.size": 6})  # Set default font size to 6\n\n    # Define labels and colors for the plot\n    labels = ["Q-CTRL Solver", "Random Sampling"]\n    colors = ["#680CE9", "#E04542"]\n\n    # Calculate total shots (total number of bitstrings in the distribution)\n    shots = sum(distribution.values())\n\n    # Generate random bitstrings for comparison (random sampling)\n    rng = np.random.default_rng(seed=0)\n    random_array = rng.integers(\n        0, 2, size=(shots, qubit_count)\n    )  # Generate random bitstrings (0 or 1 for each qubit)\n    random_bitstrings = ["".join(row.astype(str)) for row in random_array]\n\n    # Compute the cost for each random bitstring\n    random_costs = [bitstring_cost(k) for k in random_bitstrings]\n\n    # Set uniform probabilities for the random sampling\n    random_probabilities = (\n        np.ones(shape=(shots,)) / shots\n    )  # Equal probability for each random bitstring\n\n    # Find the minimum and maximum costs for binning the histogram\n    min_cost = np.min(costs)\n    max_cost = np.max(random_costs)\n\n    # Create a histogram plot with a smaller figure size (4x2 inches)\n    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(4, 2))\n\n    # Plot histograms for the Q-CTRL solver and random sampling costs\n    _, _, _ = ax.hist(\n        [costs, random_costs],  # Data for the two histograms\n        np.arange(min_cost, max_cost, 2),  # Bins for the histogram\n        weights=[\n            probabilities,\n            random_probabilities,\n        ],  # Probabilities for each data set\n        label=labels,  # Labels for the legend\n        color=colors,  # Colors for each histogram\n        histtype="stepfilled",  # Filled step histogram\n        align="mid",  # Align bars to the bin center\n        alpha=0.8,  # Transparency\n    )\n\n    # Set the x and y labels for the plot\n    ax.set_xlabel("Cost")\n    ax.set_ylabel("Probability")\n\n    # Add the legend to the plot\n    ax.legend()\n\n    # Show the plot\n    plt.show()\n'})}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Convert spin_glass_poly into a NumPy-compatible function\npoly_as_numpy_function = lambdify(x, spin_glass_poly.as_expr(), "numpy")\n\n# Function to compute the cost of a given bitstring using spin_glass_poly\ndef bitstring_cost(bitstring: str) -> float:\n    # Convert bitstring to a reversed list of integers (0s and 1s)\n    return float(\n        poly_as_numpy_function(*[int(b) for b in str(bitstring[::-1])])\n    )\n\n# Calculate the cost of each bitstring in the distribution\ncosts = [bitstring_cost(k) for k, _ in distribution.items()]\n\n# Extract probabilities from the bitstring distribution\nprobabilities = np.array([v for _, v in distribution.items()])\nprobabilities = probabilities / sum(\n    probabilities\n)  # Normalize to get probabilities\n\nplot_cost_histogram(\n    costs, probabilities, distribution, qubit_count, bitstring_cost\n)\n'})}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Output of the previous code cell",src:e(12312).A+"",width:"1115",height:"624"})})]})}function d(n={}){const{wrapper:i}={...(0,x.R)(),...n.components};return i?(0,o.jsx)(i,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}function u(n,i){throw new Error("Expected "+(i?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},12312(n,i,e){e.d(i,{A:()=>t});const t="data:image/avif;base64,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"},28453(n,i,e){e.d(i,{R:()=>a,x:()=>r});var t=e(96540);const o={},x=t.createContext(o);function a(n){const i=t.useContext(x);return t.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function r(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(x.Provider,{value:i},n.children)}}}]);