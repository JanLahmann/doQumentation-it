"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[9475],{14457(i,e,n){n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"tutorials/index","title":"Tutorial","description":"Esplora i tutorial IBM Quantum \u2014 eseguibili su RasQberry, tramite Binder o sul tuo server Jupyter.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/index.mdx","sourceDirName":"tutorials","slug":"/tutorials/","permalink":"/tutorials/","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/index.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Tutorial","sidebar_label":"Panoramica","sidebar_position":1,"description":"Esplora i tutorial IBM Quantum \u2014 eseguibili su RasQberry, tramite Binder o sul tuo server Jupyter."},"sidebar":"tutorialsSidebar","next":{"title":"Hello World: Il Vostro Primo Circuito Quantistico","permalink":"/tutorials/hello-world"}}');var t=n(74848),a=n(28453);const o={title:"Tutorial",sidebar_label:"Panoramica",sidebar_position:1,description:"Esplora i tutorial IBM Quantum \u2014 eseguibili su RasQberry, tramite Binder o sul tuo server Jupyter."},s="Tutorial {#tutorials}",l={},c=[{value:"Per iniziare",id:"get-started",level:2},{value:"Esplora i workflow verso il vantaggio quantistico",id:"explore-workflows-toward-advantage",level:2},{value:"Sfrutta le capacit\xe0 di Qiskit",id:"leverage-qiskit-capabilities",level:2}];function d(i){const e={a:"a",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...i.components},{Details:n}=e;return n||function(i,e){throw new Error("Expected "+(e?"component":"object")+" `"+i+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:["\n",(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"tutorials",children:"Tutorial"})}),"\n",(0,t.jsx)(e.p,{children:"Utilizza questi tutorial per imparare come applicare Qiskit ai casi d'uso comuni del quantum computing."}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Inizia con la serie di tutorial nella sezione ",(0,t.jsx)(e.a,{href:"#per-iniziare",children:"Per iniziare"})," se \xe8 la prima volta che esegui codice su un computer quantistico."]}),"\n",(0,t.jsxs)(e.li,{children:["La sezione sui ",(0,t.jsx)(e.a,{href:"#esplora-i-workflow-verso-il-vantaggio-quantistico",children:"workflow verso il vantaggio quantistico"})," contiene esempi end-to-end di utilizzo di un computer quantistico per risolvere problemi del mondo reale. Questi tutorial si concentrano su algoritmi che sono candidati promettenti per ottenere un vantaggio computazionale di un computer quantistico rispetto a un computer classico."]}),"\n",(0,t.jsxs)(e.li,{children:["La sezione sulle ",(0,t.jsx)(e.a,{href:"#sfrutta-le-capacit%C3%A0-di-qiskit",children:"capacit\xe0 di Qiskit"})," contiene esempi che utilizzano le tecniche pi\xf9 recenti e avanzate nell'ecosistema Qiskit per migliorare parte o l'intero flusso di lavoro particolare."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"get-started",children:"Per iniziare"}),"\n",(0,t.jsx)(e.p,{children:"Questi tutorial sono per principianti pronti ad esplorare l'esecuzione di algoritmi quantistici su un computer quantistico."}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"/tutorials/chsh-inequality",children:"Disuguaglianza CHSH"})}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"explore-workflows-toward-advantage",children:"Esplora i workflow verso il vantaggio quantistico"}),"\n",(0,t.jsx)(e.p,{children:"I tutorial in questa sezione coprono dimostrazioni su larga scala di algoritmi quantistici."}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Algoritmi di campionamento verificabile"})}),(0,t.jsx)(e.p,{children:"Gli algoritmi in questa categoria si concentrano su circuiti quantistici le cui distribuzioni di output codificano soluzioni a problemi strutturati con output verificabile. La verificabilit\xe0 significa che puoi controllare la coerenza tra i dati misurati, sia valutando la bitstring scelta sia sapendo che non si verificano falsi positivi."}),(0,t.jsx)(e.p,{children:"I tutorial evidenziano tecniche in cui il campionamento ripetuto consente la stima di quantit\xe0 specifiche del problema (ad esempio, valori di funzioni di costo o pesi spettrali). Questi metodi sono particolarmente rilevanti per compiti di ottimizzazione e simulazione con simmetrie."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/sample-based-quantum-diagonalization",children:"Diagonalizzazione quantistica basata su campionamento di un Hamiltoniano chimico"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/sample-based-krylov-quantum-diagonalization",children:"Diagonalizzazione quantistica Krylov basata su campionamento di un modello reticolare fermionico"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/quantum-approximate-optimization-algorithm",children:"Quantum approximate optimization algorithm"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/advanced-techniques-for-qaoa",children:"Tecniche avanzate per QAOA"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/pauli-correlation-encoding-for-qaoa",children:"Pauli Correlation Encoding per ridurre i requisiti Maxcut"})}),"\n"]}),"\n"]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Stima di osservabili"})}),(0,t.jsx)(e.p,{children:"Questi tutorial si concentrano sulla stima di quantit\xe0 fisicamente significative, come energia o valori di correlazione, preparando stati quantistici e misurando osservabili. Le tecniche includono approcci di circuiti sia variazionali che di Trotter che bilanciano l'espressivit\xe0 del circuito con l'efficienza della profondit\xe0 del circuito. L'enfasi \xe8 posta sui workflow che riducono le richieste di risorse quantistiche mantenendo l'accuratezza e consentendo la stima pratica di osservabili in sistemi chimici e fisici."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/krylov-quantum-diagonalization",children:"Diagonalizzazione quantistica Krylov di Hamiltoniani reticolari"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/nishimori-phase-transition",children:"Transizione di fase di Nishimori"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/spin-chain-vqe",children:"Stima dell'energia dello stato fondamentale della catena di Heisenberg con VQE"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/quantum-kernel-training",children:"Quantum kernel training"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/projected-quantum-kernels",children:"Migliora la classificazione delle feature usando projected quantum kernel"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/chsh-inequality",children:"Disuguaglianza CHSH"})}),"\n"]}),"\n"]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Algoritmi fault-tolerant"})}),(0,t.jsx)(e.p,{children:"Questa sezione presenta algoritmi con garanzie teoriche ben definite progettati per essere eseguiti su futuri hardware quantistici con correzione degli errori. I circuiti o l'overhead di campionamento per questi algoritmi scalano in modo non efficiente in profondit\xe0 e quindi hanno maggiori probabilit\xe0 di dimostrare un vantaggio quantistico quando esisteranno computer quantistici fault-tolerant. Questi tutorial illustrano come funzionano i metodi in ambienti idealizzati e dimostrano esempi su piccola scala."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"/tutorials/shors-algorithm",children:"Algoritmo di Shor"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"/tutorials/grovers-algorithm",children:"Algoritmo di Grover"})}),"\n"]})]}),"\n",(0,t.jsx)(e.h2,{id:"leverage-qiskit-capabilities",children:"Sfrutta le capacit\xe0 di Qiskit"}),"\n",(0,t.jsx)(e.p,{children:"Questa sezione introduce capacit\xe0 avanzate all'interno dell'ecosistema Qiskit che migliorano le prestazioni, l'affidabilit\xe0 e la velocit\xe0 durante l'esecuzione di algoritmi quantistici."}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Ottimizzazione del carico di lavoro"})}),(0,t.jsx)(e.p,{children:"L'ottimizzazione del carico di lavoro si concentra sull'orchestrazione efficiente delle risorse classiche e quantistiche o su metodi personalizzati per migliorare la manipolazione dei circuiti quantistici."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/edc-cut-bell-pair-benchmarking",children:"Benchmark di circuiti dinamici con cut Bell pair"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/fractional-gates",children:"Introduzione ai fractional gate"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/ai-transpiler-introduction",children:"Introduzione al servizio transpiler AI-powered di Qiskit"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/transpilation-optimizations-with-sabre",children:"Ottimizzazioni di transpilation con SABRE"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/compilation-methods-for-hamiltonian-simulation-circuits",children:"Metodi di compilazione per circuiti di simulazione Hamiltoniana"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/long-range-entanglement",children:"Entanglement a lungo raggio con circuiti dinamici"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/dc-hex-ising",children:"Simulazione di kicked Ising Hamiltonian con circuiti dinamici"})}),"\n"]}),"\n"]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Qiskit Functions"})}),(0,t.jsx)(e.p,{children:"Le Qiskit Functions sono una raccolta di strumenti di gestione degli errori e applicazioni preconfezionati, che rendono facile progettare esperimenti su larga scala con circuiti, molecole, QUBO e altro."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Progetta nuovi algoritmi con le ",(0,t.jsx)(e.strong,{children:"Circuit functions"})," -- con pipeline di transpilation, error suppression e error mitigation precostruite."]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/error-mitigation-with-qiskit-functions",children:"Error mitigation con la IBM Circuit function"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/transverse-field-ising-model",children:"Transverse-Field Ising Model con Performance Management di Q-CTRL"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/quantum-phase-estimation-qctrl",children:"Quantum Phase Estimation con le Qiskit Functions di Q-CTRL"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/qedma-2d-ising-with-qesem",children:"Simula 2D tilted-field Ising con la funzione QESEM"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["Sperimenta con problemi specifici del dominio con le ",(0,t.jsx)(e.strong,{children:"Application functions"})," -- con input e output familiari ai risolutori classici."]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/global-data-quantum-optimizer",children:"Quantum Portfolio Optimizer - A Qiskit Function by Global Data Quantum"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver",children:"Ottimizzazione binaria di ordine superiore con Optimization Solver di Q-CTRL"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/colibritd-pde",children:"Modella un fluido non viscoso in movimento usando QUICK-PDE"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/qunova-hivqe",children:"Curve PES di dissociazione con Qunova HiVQE"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/sml-classification",children:"Classificazione ensemble ibrida quantum-enhanced (workflow di stabilit\xe0 della rete)"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/solve-market-split-problem-with-iskay-quantum-optimizer",children:"Risolvi il problema Market Split con Iskay Quantum Optimizer di Kipu Quantum"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Qiskit addons"})}),(0,t.jsx)(e.p,{children:"Gli addon consentono la manipolazione avanzata di circuiti, come il taglio, la retropropagazione di osservabili o l'approssimazione di circuiti, che permettono agli utenti di aggirare le limitazioni hardware al costo di un maggiore overhead di calcolo classico."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/multi-product-formula",children:"Formule multi-prodotto per ridurre l'errore di Trotter"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/approximate-quantum-compilation-for-time-evolution",children:"Compilazione quantistica approssimata per circuiti di evoluzione temporale"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/operator-back-propagation",children:"Operator backpropagation (OBP) per la stima di valori di aspettazione"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/wire-cutting",children:"Wire cutting per la stima di valori di aspettazione"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/periodic-boundary-conditions-with-circuit-cutting",children:"Circuit cutting per condizioni al contorno periodiche"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/depth-reduction-with-circuit-cutting",children:"Circuit cutting per la riduzione della profondit\xe0"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/readout-error-mitigation-sampler",children:"Readout error mitigation per la primitiva Sampler usando M3"})}),"\n"]}),"\n"]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Error mitigation"})}),(0,t.jsx)(e.p,{children:"L'error mitigation affronta la sfida del rumore senza una completa fault tolerance recuperando valori di aspettazione accurati attraverso la manipolazione controllata dei circuiti e il post-processing."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/probabilistic-error-amplification",children:"Error mitigation a scala di utilit\xe0 con amplificazione probabilistica dell'errore"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/combine-error-mitigation-techniques",children:"Combina opzioni di error mitigation con la primitiva Estimator"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/real-time-benchmarking-for-qubit-selection",children:"Benchmarking in tempo reale per la selezione dei qubit"})}),"\n"]}),"\n"]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(e.strong,{children:"Error detection"})}),(0,t.jsx)(e.p,{children:"L'error detection identifica operazioni difettose per restituire risultati privi di rumore shot-by-shot tramite post-processing."}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/repetition-codes",children:"Codici di ripetizione"})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.a,{href:"/tutorials/ghz-spacetime-codes",children:"Error detection a basso overhead con codici spaziotemporali"})}),"\n"]}),"\n"]})]})]})}function u(i={}){const{wrapper:e}={...(0,a.R)(),...i.components};return e?(0,t.jsx)(e,{...i,children:(0,t.jsx)(d,{...i})}):d(i)}},28453(i,e,n){n.d(e,{R:()=>o,x:()=>s});var r=n(96540);const t={},a=r.createContext(t);function o(i){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function s(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(t):i.components||t:o(i.components),r.createElement(a.Provider,{value:e},i.children)}}}]);