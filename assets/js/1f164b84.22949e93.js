"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1857],{37344(i,e,n){n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"tutorials/ai-transpiler-introduction","title":"Introduzione al servizio di transpiler AI-powered di Qiskit","description":"In questo notebook, esploreremo i principali vantaggi del servizio di transpiler AI-powered di Qiskit e come si confronta con i metodi tradizionali.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/ai-transpiler-introduction.mdx","sourceDirName":"tutorials","slug":"/tutorials/ai-transpiler-introduction","permalink":"/tutorials/ai-transpiler-introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/ai-transpiler-introduction.mdx","tags":[],"version":"current","frontMatter":{"title":"Introduzione al servizio di transpiler AI-powered di Qiskit","sidebar_label":"Introduzione al servizio di transpiler AI-powered di Qiskit","description":"In questo notebook, esploreremo i principali vantaggi del servizio di transpiler AI-powered di Qiskit e come si confronta con i metodi tradizionali.","notebook_path":"docs/tutorials/ai-transpiler-introduction.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Introduzione ai gate frazionari","permalink":"/tutorials/fractional-gates"},"next":{"title":"Ottimizzazioni di transpilazione con SABRE","permalink":"/tutorials/transpilation-optimizations-with-sabre"}}');var a=n(74848),s=n(28453);const r={title:"Introduzione al servizio di transpiler AI-powered di Qiskit",sidebar_label:"Introduzione al servizio di transpiler AI-powered di Qiskit",description:"In questo notebook, esploreremo i principali vantaggi del servizio di transpiler AI-powered di Qiskit e come si confronta con i metodi tradizionali.",notebook_path:"docs/tutorials/ai-transpiler-introduction.ipynb"},o=void 0,l={},c=[{value:"Background",id:"background",level:2},{value:"Caratteristiche principali dei pass AI",id:"key-features-of-ai-passes",level:3},{value:"Perch\xe9 utilizzare l&#39;AI per la transpilazione dei circuiti quantistici?",id:"why-use-ai-for-quantum-circuit-transpilation",level:3},{value:"Brevi risultati di benchmarking",id:"brief-benchmarking-results",level:3},{value:"Requisiti",id:"requirements",level:2},{value:"Configurazione",id:"setup",level:2},{value:"Passo 1: Mappare gli input classici in un problema quantistico",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Passo 2: Ottimizzare il problema per l&#39;esecuzione su hardware quantistico",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Scegliere un backend",id:"choose-a-backend",level:3},{value:"Creare pass manager AI e tradizionali",id:"create-ai-and-traditional-pass-managers",level:3},{value:"Passo 3: Eseguire utilizzando i primitive di Qiskit",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Passo 4: Post-elaborare e restituire il risultato nel formato classico desiderato",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Quando gli utenti dovrebbero scegliere la transpilazione basata su AI?",id:"when-should-users-choose-ai-powered-transpilation",level:2},{value:"Step 1: Mappare gli input classici a un problema quantistico",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Step 2: Ottimizzare il problema per l&#39;esecuzione su hardware quantistico",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Step 3: Eseguire utilizzando le primitive di Qiskit",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Step 4: Post-elaborare e restituire il risultato nel formato classico desiderato",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Sondaggio del tutorial",id:"tutorial-survey",level:2}];function d(i){const e={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,s.R)(),...i.components},{OpenInLabBanner:t}=e;return t||function(i,e){throw new Error("Expected "+(e?"component":"object")+" `"+i+"` to be defined: you likely forgot to import, pass, or provide it.")}("OpenInLabBanner",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t,{notebookPath:"docs/tutorials/ai-transpiler-introduction.ipynb"}),"\n","\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.em,{children:"Utilizzo stimato di QPU: Nessuno (NOTA: Questo tutorial non esegue job perch\xe9 \xe8 focalizzato sulla transpilazione)"})}),"\n",(0,a.jsx)(e.h2,{id:"background",children:"Background"}),"\n",(0,a.jsxs)(e.p,{children:["Il ",(0,a.jsx)(e.strong,{children:"servizio di transpiler AI-powered di Qiskit (QTS)"})," introduce ottimizzazioni basate su machine learning sia nei pass di routing che di sintesi. Queste modalit\xe0 AI sono state progettate per affrontare le limitazioni della transpilazione tradizionale, in particolare per circuiti su larga scala e topologie hardware complesse."]}),"\n",(0,a.jsxs)(e.p,{children:["A partire da ",(0,a.jsx)(e.strong,{children:"luglio 2025"}),", il ",(0,a.jsx)(e.strong,{children:"Transpiler Service"})," \xe8 stato migrato sulla nuova piattaforma IBM Quantum\xae e non \xe8 pi\xf9 disponibile. Per gli ultimi aggiornamenti sullo stato del Transpiler Service, consultate la ",(0,a.jsx)(e.a,{href:"/guides/qiskit-transpiler-service",children:"documentazione del servizio di transpiler"}),". Potete comunque utilizzare il transpiler AI localmente, in modo simile alla transpilazione standard di Qiskit. \xc8 sufficiente sostituire ",(0,a.jsx)(e.code,{children:"generate_preset_pass_manager()"})," con ",(0,a.jsx)(e.code,{children:"generate_ai_pass_manager()"}),". Questa funzione costruisce un pass manager che integra i pass di routing e sintesi AI-powered direttamente nel vostro flusso di lavoro di transpilazione locale."]}),"\n",(0,a.jsx)(e.h3,{id:"key-features-of-ai-passes",children:"Caratteristiche principali dei pass AI"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Pass di routing: Il routing AI-powered pu\xf2 regolare dinamicamente i percorsi dei qubit in base al circuito specifico e al backend, riducendo la necessit\xe0 di eccessivi gate SWAP."}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"AIRouting"}),": Selezione del layout e routing del circuito"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Pass di sintesi: Le tecniche AI ottimizzano la decomposizione di gate multi-qubit, minimizzando il numero di gate a due qubit, che sono tipicamente pi\xf9 soggetti a errori."}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"AICliffordSynthesis"}),": Sintesi di gate Clifford"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"AILinearFunctionSynthesis"}),": Sintesi di circuiti di funzioni lineari"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"AIPermutationSynthesis"}),": Sintesi di circuiti di permutazione"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"AIPauliNetworkSynthesis"}),": Sintesi di circuiti di Pauli Network (disponibile solo nel Qiskit Transpiler Service, non nell'ambiente locale)"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Confronto con la transpilazione tradizionale: Il transpiler standard di Qiskit \xe8 uno strumento robusto in grado di gestire efficacemente un ampio spettro di circuiti quantistici. Tuttavia, quando i circuiti crescono in scala o le configurazioni hardware diventano pi\xf9 complesse, i pass AI possono fornire ulteriori guadagni di ottimizzazione. Utilizzando modelli appresi per il routing e la sintesi, QTS perfeziona ulteriormente i layout dei circuiti e riduce l'overhead per compiti quantistici complessi o su larga scala."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Questo tutorial valuta le modalit\xe0 AI utilizzando sia i pass di routing che di sintesi, confrontando i risultati con la transpilazione tradizionale per evidenziare dove l'AI offre guadagni di prestazione."}),"\n",(0,a.jsxs)(e.p,{children:["Per maggiori dettagli sui pass AI disponibili, consultate la ",(0,a.jsx)(e.a,{href:"/guides/ai-transpiler-passes",children:"documentazione dei pass AI"}),"."]}),"\n",(0,a.jsx)(e.h3,{id:"why-use-ai-for-quantum-circuit-transpilation",children:"Perch\xe9 utilizzare l'AI per la transpilazione dei circuiti quantistici?"}),"\n",(0,a.jsx)(e.p,{children:"Man mano che i circuiti quantistici crescono in dimensione e complessit\xe0, i metodi di transpilazione tradizionali faticano a ottimizzare i layout e ridurre efficacemente il numero di gate. I circuiti pi\xf9 grandi, in particolare quelli che coinvolgono centinaia di qubit, pongono sfide significative per il routing e la sintesi a causa dei vincoli del dispositivo, della connettivit\xe0 limitata e dei tassi di errore dei qubit."}),"\n",(0,a.jsx)(e.p,{children:"\xc8 qui che la transpilazione AI-powered offre una soluzione potenziale. Sfruttando tecniche di machine learning, il transpiler AI-powered in Qiskit pu\xf2 prendere decisioni pi\xf9 intelligenti riguardo al routing dei qubit e alla sintesi dei gate, portando a una migliore ottimizzazione dei circuiti quantistici su larga scala."}),"\n",(0,a.jsx)(e.h3,{id:"brief-benchmarking-results",children:"Brevi risultati di benchmarking"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Graph showing AI transpiler performance against Qiskit",src:n(21504).A+"",width:"956",height:"738"})}),"\n",(0,a.jsxs)(e.p,{children:["Nei test di benchmarking, il transpiler AI ha prodotto costantemente circuiti pi\xf9 superficiali e di qualit\xe0 superiore rispetto al transpiler standard di Qiskit. Per questi test, abbiamo utilizzato la strategia predefinita del pass manager di Qiskit, configurata con [",(0,a.jsx)(e.code,{children:"generate_preset_passmanager"}),"]. Sebbene questa strategia predefinita sia spesso efficace, pu\xf2 avere difficolt\xe0 con circuiti pi\xf9 grandi o pi\xf9 complessi. Al contrario, i pass AI-powered hanno ottenuto una riduzione media del 24% nel numero di gate a due qubit e una riduzione del 36% nella profondit\xe0 del circuito per circuiti grandi (100+ qubit) durante la transpilazione alla topologia heavy-hex dell'hardware IBM Quantum. Per maggiori informazioni su questi benchmark, consultate questo ",(0,a.jsx)(e.a,{href:"https://www.ibm.com/quantum/blog/qiskit-performance",children:"blog."})]}),"\n",(0,a.jsx)(e.p,{children:"Questo tutorial esplora i principali vantaggi dei pass AI e come si confrontano con i metodi tradizionali."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-ibm-transpiler\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# This cell is hidden from users;\n# it just disables a linting rule.\n# ruff: noqa: F811\n"})}),"\n",(0,a.jsx)(e.h2,{id:"requirements",children:"Requisiti"}),"\n",(0,a.jsx)(e.p,{children:"Prima di iniziare questo tutorial, assicuratevi di avere installato quanto segue:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["Qiskit SDK v1.0 o successivo, con supporto per la ",(0,a.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualizzazione"})]}),"\n",(0,a.jsxs)(e.li,{children:["Qiskit Runtime (",(0,a.jsx)(e.code,{children:"pip install qiskit-ibm-runtime"}),") v0.22 o successivo"]}),"\n",(0,a.jsxs)(e.li,{children:["Qiskit IBM\xae Transpiler con modalit\xe0 locale AI (",(0,a.jsx)(e.code,{children:"pip install 'qiskit-ibm-transpiler[ai-local-mode]'"}),")"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"setup",children:"Configurazione"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from qiskit import QuantumCircuit\nfrom qiskit.circuit.library import efficient_su2, PermutationGate\nfrom qiskit.synthesis.qft import synth_qft_full\nfrom qiskit.circuit.random import random_circuit, random_clifford_circuit\nfrom qiskit.transpiler import generate_preset_pass_manager, CouplingMap\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_transpiler import generate_ai_pass_manager\nfrom qiskit.synthesis.permutation import (\n    synth_permutation_depth_lnn_kms,\n    synth_permutation_basic,\n)\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport time\nimport logging\n\nseed = 42\n\n# Used for generating permutation circuits in part two for comparison\ndef generate_permutation_circuit(width, pattern):\n    circuit = QuantumCircuit(width)\n    circuit.append(\n        PermutationGate(pattern=pattern),\n        qargs=range(width),\n    )\n    return circuit\n\n# Creates a Bernstein-Vazirani circuit given the number of qubits\ndef create_bv_circuit(num_qubits):\n    qc = QuantumCircuit(num_qubits, num_qubits - 1)\n    qc.x(num_qubits - 1)\n    qc.h(qc.qubits)\n    for i in range(num_qubits - 1):\n        qc.cx(i, num_qubits - 1)\n    qc.h(qc.qubits[:-1])\n    return qc\n\n# Transpile a circuit with a given pass manager and return metrics\ndef transpile_with_metrics(pass_manager, circuit):\n    start = time.time()\n    qc_out = pass_manager.run(circuit)\n    elapsed = time.time() - start\n\n    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)\n    gate_count = qc_out.size()\n\n    return qc_out, {\n        "depth_2q": depth_2q,\n        "gate_count": gate_count,\n        "time_s": elapsed,\n    }\n\n# Used for collecting metrics for part 3 of synthesis methods\ndef synth_transpile_with_metrics(qc, pm, pattern_id, method):\n    start = time.time()\n    qc = pm.run(qc)\n    elapsed = time.time() - start\n\n    return {\n        "Pattern": pattern_id,\n        "Method": method,\n        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),\n        "Gates": qc.size(),\n        "Time (s)": elapsed,\n    }\n\n# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"\n\nlogging.getLogger(\n    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"\n).setLevel(logging.WARNING)\n'})}),"\n",(0,a.jsx)(e.h1,{id:"part-i-qiskit-patterns",children:"Parte I. Pattern di Qiskit"}),"\n",(0,a.jsxs)(e.p,{children:["Vediamo ora come utilizzare il servizio di transpiler AI con un semplice circuito quantistico, utilizzando i pattern di Qiskit. La chiave consiste nel creare un ",(0,a.jsx)(e.code,{children:"PassManager"})," con ",(0,a.jsx)(e.code,{children:"generate_ai_pass_manager()"})," invece del ",(0,a.jsx)(e.code,{children:"generate_preset_pass_manager()"})," standard."]}),"\n",(0,a.jsx)(e.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Passo 1: Mappare gli input classici in un problema quantistico"}),"\n",(0,a.jsxs)(e.p,{children:["In questa sezione, testeremo il transpiler AI sul circuito ",(0,a.jsx)(e.code,{children:"efficient_su2"}),", un ansatz hardware-efficient ampiamente utilizzato. Questo circuito \xe8 particolarmente rilevante per gli algoritmi quantistici variazionali (ad esempio, VQE) e i compiti di machine learning quantistico, rendendolo un caso di test ideale per valutare le prestazioni di transpilazione."]}),"\n",(0,a.jsxs)(e.p,{children:["Il circuito ",(0,a.jsx)(e.code,{children:"efficient_su2"})," consiste in strati alternati di rotazioni a singolo qubit e gate di entanglement come i CNOT. Questi strati consentono un'esplorazione flessibile dello spazio degli stati quantistici mantenendo la profondit\xe0 del gate gestibile. Ottimizzando questo circuito, miriamo a ridurre il numero di gate, migliorare la fedelt\xe0 e minimizzare il rumore. Questo lo rende un candidato forte per testare l'efficienza del transpiler AI."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# For our transpilation, we will use a large circuit of 101 qubits\nqc = efficient_su2(90, entanglement="circular", reps=1).decompose()\n\n# Draw a smaller version of the circuit to get a visual representation\nqc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()\nqc_small.draw(output="mpl")\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Output of the previous code cell",src:n(90654).A+"",width:"874",height:"378"})}),"\n",(0,a.jsx)(e.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Passo 2: Ottimizzare il problema per l'esecuzione su hardware quantistico"}),"\n",(0,a.jsx)(e.h3,{id:"choose-a-backend",children:"Scegliere un backend"}),"\n",(0,a.jsx)(e.p,{children:"Per questo esempio, selezioniamo il backend IBM Quantum operativo meno occupato che non sia un simulatore e abbia almeno 100 qubit:"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Nota:"})," Poich\xe9 il backend meno occupato pu\xf2 cambiare nel tempo, dispositivi diversi potrebbero essere selezionati per esecuzioni diverse. Le propriet\xe0 specifiche del dispositivo, come le mappe di accoppiamento, possono portare a differenze nei circuiti transpilati."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'service = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=100\n)\ncm = backend.coupling_map\nprint(f"Using backend: {backend.name}")\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-text",children:"Using backend: ibm_torino\n"})}),"\n",(0,a.jsx)(e.h3,{id:"create-ai-and-traditional-pass-managers",children:"Creare pass manager AI e tradizionali"}),"\n",(0,a.jsx)(e.p,{children:"Per valutare l'efficacia del transpiler AI, eseguiremo due esecuzioni di transpilazione. Prima, traspilaremo il circuito utilizzando il transpiler AI. Poi, eseguiremo un confronto transpilando lo stesso circuito senza il transpiler AI, utilizzando metodi tradizionali. Entrambi i processi di transpilazione utilizzeranno la stessa mappa di accoppiamento dal backend scelto e il livello di ottimizzazione impostato a 3 per un confronto equo."}),"\n",(0,a.jsxs)(e.p,{children:["Entrambi questi metodi riflettono l'approccio standard per creare istanze di ",(0,a.jsx)(e.code,{children:"PassManager"})," per transpilare circuiti in Qiskit."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"pm_ai = generate_ai_pass_manager(\n    optimization_level=3,\n    ai_optimization_level=3,\n    coupling_map=cm,\n    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods\n)\n\npm_no_ai = generate_preset_pass_manager(\n    optimization_level=3,\n    coupling_map=cm,\n    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding\n)\n"})}),"\n",(0,a.jsx)(e.p,{children:"Transpilate i circuiti e registrate i tempi."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Transpile using standard (non-AI) pass manager\n_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)\nprint(\n    f\"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, \"\n    f\"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}\"\n)\n\n# Transpile using AI pass manager\n_, metrics_ai = transpile_with_metrics(pm_ai, qc)\nprint(\n    f\"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, \"\n    f\"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}\"\n)\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-text",children:"Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629\nAI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547\n"})}),"\n",(0,a.jsx)(e.p,{children:"In questo test, confrontiamo le prestazioni del transpiler AI e del metodo di transpilazione standard sul circuito efficient_su2. Il transpiler AI raggiunge una profondit\xe0 del circuito notevolmente inferiore mantenendo un numero di gate simile."}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Profondit\xe0 del circuito:"})," Il transpiler AI produce un circuito con una profondit\xe0 a due qubit inferiore. Questo \xe8 previsto, poich\xe9 i pass AI sono addestrati per ottimizzare la profondit\xe0 apprendendo i pattern di interazione dei qubit e sfruttando la connettivit\xe0 hardware in modo pi\xf9 efficace rispetto alle euristiche basate su regole."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Numero di gate:"})," Il numero totale di gate rimane simile tra i due metodi. Ci\xf2 \xe8 in linea con le aspettative poich\xe9 la transpilazione standard basata su SABRE minimizza esplicitamente il numero di swap, che domina l'overhead dei gate. Il transpiler AI invece d\xe0 priorit\xe0 alla profondit\xe0 complessiva e pu\xf2 occasionalmente scambiare alcuni gate aggiuntivi per un percorso di esecuzione pi\xf9 breve."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Tempo di transpilazione:"})," Il transpiler AI richiede pi\xf9 tempo per l'esecuzione rispetto al metodo standard. Ci\xf2 \xe8 dovuto al costo computazionale aggiuntivo derivante dall'invocazione di modelli appresi durante il routing e la sintesi. Al contrario, il transpiler basato su SABRE \xe8 ora significativamente pi\xf9 veloce dopo essere stato riscritto e ottimizzato in Rust, fornendo un routing euristico altamente efficiente su larga scala."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["\xc8 importante notare che questi risultati si basano su un solo circuito. Per ottenere una comprensione completa di come il transpiler AI si confronta con i metodi tradizionali, \xe8 necessario testare una variet\xe0 di circuiti. Le prestazioni di QTS possono variare notevolmente a seconda del tipo di circuito che viene ottimizzato. Per un confronto pi\xf9 ampio, consultate i benchmark sopra o visitate il ",(0,a.jsx)(e.a,{href:"https://www.ibm.com/quantum/blog/qiskit-performance",children:"blog."})]}),"\n",(0,a.jsx)(e.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Passo 3: Eseguire utilizzando i primitive di Qiskit"}),"\n",(0,a.jsx)(e.p,{children:"Poich\xe9 questo tutorial si concentra sulla transpilazione, nessun esperimento verr\xe0 eseguito sul dispositivo quantistico. L'obiettivo \xe8 sfruttare le ottimizzazioni del Passo 2 per ottenere un circuito transpilato con profondit\xe0 o numero di gate ridotti."}),"\n",(0,a.jsx)(e.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Passo 4: Post-elaborare e restituire il risultato nel formato classico desiderato"}),"\n",(0,a.jsx)(e.p,{children:"Poich\xe9 non c'\xe8 esecuzione per questo notebook, non ci sono risultati da post-elaborare."}),"\n",(0,a.jsx)(e.h1,{id:"part-ii-analyze-and-benchmark-the-transpiled-circuits",children:"Parte II. Analizzare e fare benchmark dei circuiti transpilati"}),"\n",(0,a.jsx)(e.p,{children:"In questa sezione, dimostreremo come analizzare il circuito transpilato e fare il suo benchmark rispetto alla versione originale in modo pi\xf9 dettagliato. Ci concentreremo su metriche come la profondit\xe0 del circuito, il numero di gate e il tempo di transpilazione per valutare l'efficacia dell'ottimizzazione. Inoltre, discuteremo di come i risultati possano differire tra vari tipi di circuiti, offrendo approfondimenti sulle prestazioni pi\xf9 ampie del transpiler in diversi scenari."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Circuits to benchmark\nseed = 42\ncircuits = [\n    {\n        "name": "Random",\n        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),\n    },\n    {\n        "name": "Clifford",\n        "qc": random_clifford_circuit(\n            num_qubits=40, num_gates=200, seed=seed\n        ),\n    },\n    {\n        "name": "QFT",\n        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),\n    },\n    {\n        "name": "BV",\n        "qc": create_bv_circuit(40),\n    },\n]\n\nresults = []\n\n# Run the transpilation for each circuit and store the results\nfor circuit in circuits:\n    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])\n    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])\n\n    print("Completed transpilation for", circuit["name"])\n\n    results.append(\n        {\n            "Circuit": circuit["name"],\n            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],\n            "Gate Count (No AI)": metrics_no_ai["gate_count"],\n            "Time (No AI)": metrics_no_ai["time_s"],\n            "Depth 2Q (AI)": metrics_ai["depth_2q"],\n            "Gate Count (AI)": metrics_ai["gate_count"],\n            "Time (AI)": metrics_ai["time_s"],\n        }\n    )\n\ndf = pd.DataFrame(results)\ndf\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-text",children:"Completed transpilation for Random\nCompleted transpilation for Clifford\nCompleted transpilation for QFT\nCompleted transpilation for BV\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-text",children:"Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \\\n0    Random                37                 221      0.039347\n1  Clifford                36                 232      0.036633\n2       QFT               165                 924      0.077458\n3        BV                65                 155      0.024993\n\n   Depth 2Q (AI)  Gate Count (AI)  Time (AI)\n0             24              181   0.773718\n1             43              267   1.097431\n2            130              913   3.660771\n3             70              155   0.345522\n"})}),"\n",(0,a.jsx)(e.p,{children:"Riduzione percentuale media per ciascuna metrica. I valori positivi indicano miglioramenti, quelli negativi peggioramenti."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Average reduction from non-AI to AI transpilation as a percentage\navg_reduction_depth = (\n    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()\n    / df["Depth 2Q (No AI)"].mean()\n    * 100\n)\navg_reduction_gates = (\n    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()\n    / df["Gate Count (No AI)"].mean()\n    * 100\n)\navg_reduction_time = (\n    (df["Time (No AI)"] - df["Time (AI)"]).mean()\n    / df["Time (No AI)"].mean()\n    * 100\n)\n\nprint(f"Average reduction in depth: {avg_reduction_depth:.2f}%")\nprint(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")\nprint(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-text",children:"Average reduction in depth: 11.88%\nAverage reduction in gate count: 1.04%\nAverage reduction in transpilation time: -3193.95%\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'fig, axs = plt.subplots(1, 3, figsize=(21, 6))\ndf.plot(\n    x="Circuit",\n    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],\n    kind="bar",\n    ax=axs[0],\n)\naxs[0].set_title("Circuit Depth Comparison")\naxs[0].set_ylabel("Depth")\naxs[0].set_xlabel("Circuit")\naxs[0].tick_params(axis="x", rotation=45)\ndf.plot(\n    x="Circuit",\n    y=["Gate Count (No AI)", "Gate Count (AI)"],\n    kind="bar",\n    ax=axs[1],\n)\naxs[1].set_title("Gate Count Comparison")\naxs[1].set_ylabel("Gate Count")\naxs[1].set_xlabel("Circuit")\naxs[1].tick_params(axis="x", rotation=45)\ndf.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])\naxs[2].set_title("Time Comparison")\naxs[2].set_ylabel("Time (seconds)")\naxs[2].set_xlabel("Circuit")\naxs[2].tick_params(axis="x", rotation=45)\nfig.suptitle(\n    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"\n)\n\nplt.tight_layout()\nplt.show()\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Output of the previous code cell",src:n(69619).A+"",width:"2090",height:"593"})}),"\n",(0,a.jsx)(e.p,{children:"Le prestazioni del transpiler AI variano significativamente in base al tipo di circuito che viene ottimizzato. In alcuni casi, raggiunge riduzioni notevoli nella profondit\xe0 del circuito e nel numero di gate rispetto al transpiler standard. Tuttavia, questi miglioramenti spesso comportano un aumento sostanziale del tempo di esecuzione."}),"\n",(0,a.jsx)(e.p,{children:"Per determinati tipi di circuiti, il transpiler AI pu\xf2 produrre risultati leggermente migliori in termini di profondit\xe0 del circuito, ma pu\xf2 anche portare a un aumento nel numero di gate e una penalit\xe0 significativa nel tempo di esecuzione. Queste osservazioni suggeriscono che i benefici del transpiler AI non sono uniformi tra tutti i tipi di circuiti. Al contrario, la sua efficacia dipende dalle caratteristiche specifiche del circuito, rendendolo pi\xf9 adatto per alcuni casi d'uso rispetto ad altri."}),"\n",(0,a.jsx)(e.h2,{id:"when-should-users-choose-ai-powered-transpilation",children:"Quando gli utenti dovrebbero scegliere la transpilazione basata su AI?"}),"\n",(0,a.jsx)(e.p,{children:"Il transpilatore basato su AI in Qiskit eccelle in scenari in cui i metodi di transpilazione tradizionali incontrano difficolt\xe0, in particolare con circuiti quantistici di grandi dimensioni e complessi. Per circuiti che coinvolgono centinaia di qubit o che hanno come target hardware con mappe di accoppiamento intricate, il transpilatore AI offre un'ottimizzazione superiore in termini di profondit\xe0 del circuito, conteggio dei gate ed efficienza di runtime. Nei test di benchmarking, ha costantemente superato i metodi tradizionali, fornendo circuiti significativamente pi\xf9 ridotti in profondit\xe0 e riducendo il conteggio dei gate, aspetti critici per migliorare le prestazioni e mitigare il rumore su hardware quantistico reale."}),"\n",(0,a.jsx)(e.p,{children:"Gli utenti dovrebbero considerare la transpilazione basata su AI quando lavorano con:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Circuiti di grandi dimensioni in cui i metodi tradizionali non riescono a gestire efficacemente la scala."}),"\n",(0,a.jsx)(e.li,{children:"Topologie hardware complesse in cui sorgono sfide di connettivit\xe0 del dispositivo e di routing."}),"\n",(0,a.jsx)(e.li,{children:"Applicazioni sensibili alle prestazioni in cui ridurre la profondit\xe0 del circuito e migliorare la fedelt\xe0 sono di fondamentale importanza."}),"\n"]}),"\n",(0,a.jsx)(e.h1,{id:"part-iii-explore-ai-powered-permutation-network-synthesis",children:"Parte III. Esplorare la sintesi di reti di permutazione basata su AI"}),"\n",(0,a.jsx)(e.p,{children:"Le reti di permutazione sono fondamentali nel calcolo quantistico, in particolare per sistemi vincolati da topologie limitate. Queste reti facilitano interazioni a lungo raggio scambiando dinamicamente i qubit per simulare una connettivit\xe0 all-to-all su hardware con connettivit\xe0 limitata. Tali trasformazioni sono essenziali per implementare algoritmi quantistici complessi su dispositivi a breve termine, dove le interazioni spesso si estendono oltre i vicini pi\xf9 prossimi."}),"\n",(0,a.jsxs)(e.p,{children:["In questa sezione, evidenziamo la sintesi di reti di permutazione come un caso d'uso convincente per il transpilatore basato su AI in Qiskit. Nello specifico, il pass ",(0,a.jsx)(e.code,{children:"AIPermutationSynthesis"})," sfrutta l'ottimizzazione guidata da AI per generare circuiti efficienti per attivit\xe0 di permutazione di qubit. Al contrario, gli approcci di sintesi generica spesso faticano a bilanciare il conteggio dei gate e la profondit\xe0 del circuito, specialmente in scenari con interazioni dense di qubit o quando si tenta di ottenere una connettivit\xe0 completa."]}),"\n",(0,a.jsxs)(e.p,{children:["Vi guideremo attraverso un esempio di pattern Qiskit che mostra la sintesi di una rete di permutazione per ottenere una connettivit\xe0 all-to-all per un insieme di qubit. Confronteremo le prestazioni di ",(0,a.jsx)(e.code,{children:"AIPermutationSynthesis"})," con i metodi di sintesi standard in Qiskit. Questo esempio dimostrer\xe0 come il transpilatore AI ottimizzi per una minore profondit\xe0 del circuito e un minore conteggio dei gate, evidenziando i suoi vantaggi nei flussi di lavoro quantistici pratici. Per attivare il pass di sintesi AI, utilizzeremo la funzione ",(0,a.jsx)(e.code,{children:"generate_ai_pass_manager()"})," con il parametro ",(0,a.jsx)(e.code,{children:"include_ai_synthesis"})," impostato su ",(0,a.jsx)(e.code,{children:"True"}),"."]}),"\n",(0,a.jsx)(e.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Step 1: Mappare gli input classici a un problema quantistico"}),"\n",(0,a.jsx)(e.p,{children:"Per rappresentare un problema di permutazione classico su un computer quantistico, iniziamo definendo la struttura dei circuiti quantistici. Per questo esempio:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Inizializzazione del circuito quantistico:\nAllochiamo 27 qubit per corrispondere al backend che useremo, che ha 27 qubit."}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:["Applicare le permutazioni:\nGeneriamo dieci pattern di permutazione casuali (da ",(0,a.jsx)(e.code,{children:"pattern_1"})," a ",(0,a.jsx)(e.code,{children:"pattern_10"}),") utilizzando un seed fisso per la riproducibilit\xe0. Ogni pattern di permutazione viene applicato a un circuito quantistico separato (da ",(0,a.jsx)(e.code,{children:"qc_1"})," a ",(0,a.jsx)(e.code,{children:"qc_10"}),")."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"Decomposizione del circuito:\nOgni operazione di permutazione viene decomposta in set di gate nativi compatibili con l'hardware quantistico target. Analizziamo la profondit\xe0 e il numero di gate a due qubit (gate non locali) per ogni circuito decomposto."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"I risultati forniscono informazioni sulla complessit\xe0 della rappresentazione di problemi di permutazione classici su un dispositivo quantistico, dimostrando i requisiti di risorse per diversi pattern di permutazione."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Parameters\nwidth = 27\nnum_circuits = 10\n\n# Set random seed\nnp.random.seed(seed)\n\n# Generate random patterns and circuits\npatterns = [\n    np.random.permutation(width).tolist() for _ in range(num_circuits)\n]\ncircuits = {\n    f"qc_{i}": generate_permutation_circuit(width, pattern)\n    for i, pattern in enumerate(patterns, start=1)\n}\n\n# Display one of the circuits\ncircuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Output of the previous code cell",src:n(40641).A+"",width:"2895",height:"1784"})}),"\n",(0,a.jsx)(e.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Step 2: Ottimizzare il problema per l'esecuzione su hardware quantistico"}),"\n",(0,a.jsx)(e.p,{children:"In questo step, procediamo con l'ottimizzazione utilizzando i pass di sintesi AI."}),"\n",(0,a.jsxs)(e.p,{children:["Per i pass di sintesi AI, il ",(0,a.jsx)(e.code,{children:"PassManager"})," richiede solo la mappa di accoppiamento del backend. Tuttavia, \xe8 importante notare che non tutte le mappe di accoppiamento sono compatibili; funzioneranno solo quelle su cui il pass ",(0,a.jsx)(e.code,{children:"AIPermutationSynthesis"})," \xe8 stato addestrato. Attualmente, il pass ",(0,a.jsx)(e.code,{children:"AIPermutationSynthesis"})," supporta blocchi di dimensioni 65, 33 e 27 qubit. Per questo esempio utilizziamo una QPU a 27 qubit."]}),"\n",(0,a.jsx)(e.p,{children:"Per confronto, valuteremo le prestazioni della sintesi AI rispetto ai metodi di sintesi di permutazione generici in Qiskit, inclusi:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"synth_permutation_depth_lnn_kms"}),": Questo metodo sintetizza un circuito di permutazione per un'architettura linear nearest-neighbor (LNN) utilizzando l'algoritmo Kutin, Moulton e Smithline (KMS). Garantisce un circuito con una profondit\xe0 di al massimo ",(0,a.jsxs)(e.span,{className:"katex",children:[(0,a.jsx)(e.span,{className:"katex-mathml",children:(0,a.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(e.semantics,{children:[(0,a.jsx)(e.mrow,{children:(0,a.jsx)(e.mi,{children:"n"})}),(0,a.jsx)(e.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,a.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(e.span,{className:"base",children:[(0,a.jsx)(e.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(e.span,{className:"mord mathnormal",children:"n"})]})})]})," e una dimensione di al massimo ",(0,a.jsxs)(e.span,{className:"katex",children:[(0,a.jsx)(e.span,{className:"katex-mathml",children:(0,a.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(e.semantics,{children:[(0,a.jsxs)(e.mrow,{children:[(0,a.jsx)(e.mi,{children:"n"}),(0,a.jsx)(e.mo,{stretchy:"false",children:"("}),(0,a.jsx)(e.mi,{children:"n"}),(0,a.jsx)(e.mo,{children:"\u2212"}),(0,a.jsx)(e.mn,{children:"1"}),(0,a.jsx)(e.mo,{stretchy:"false",children:")"}),(0,a.jsx)(e.mi,{mathvariant:"normal",children:"/"}),(0,a.jsx)(e.mn,{children:"2"})]}),(0,a.jsx)(e.annotation,{encoding:"application/x-tex",children:"n(n-1)/2"})]})})}),(0,a.jsxs)(e.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(e.span,{className:"base",children:[(0,a.jsx)(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(e.span,{className:"mopen",children:"("}),(0,a.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,a.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(e.span,{className:"mbin",children:"\u2212"}),(0,a.jsx)(e.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(e.span,{className:"base",children:[(0,a.jsx)(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(e.span,{className:"mord",children:"1"}),(0,a.jsx)(e.span,{className:"mclose",children:")"}),(0,a.jsx)(e.span,{className:"mord",children:"/2"})]})]})]}),", dove sia la profondit\xe0 che la dimensione sono misurate in termini di gate SWAP."]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"synth_permutation_basic"}),": Questa \xe8 un'implementazione semplice che sintetizza circuiti di permutazione senza imporre vincoli sulla connettivit\xe0 o sull'ottimizzazione per architetture specifiche. Serve come baseline per confrontare le prestazioni con metodi pi\xf9 avanzati."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Ciascuno di questi metodi rappresenta un approccio distinto alla sintesi di reti di permutazione, fornendo un benchmark completo rispetto ai metodi basati su AI."}),"\n",(0,a.jsxs)(e.p,{children:["Per maggiori dettagli sui metodi di sintesi in Qiskit, consultare la ",(0,a.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/synthesis",children:"documentazione API di Qiskit"}),".\nDefinire la mappa di accoppiamento che rappresenta la QPU a 27 qubit."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"coupling_map = [\n    [1, 0],\n    [2, 1],\n    [3, 2],\n    [3, 5],\n    [4, 1],\n    [6, 7],\n    [7, 4],\n    [7, 10],\n    [8, 5],\n    [8, 9],\n    [8, 11],\n    [11, 14],\n    [12, 10],\n    [12, 13],\n    [12, 15],\n    [13, 14],\n    [16, 14],\n    [17, 18],\n    [18, 15],\n    [18, 21],\n    [19, 16],\n    [19, 22],\n    [20, 19],\n    [21, 23],\n    [23, 24],\n    [25, 22],\n    [25, 24],\n    [26, 25],\n]\nCouplingMap(coupling_map).draw()\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Output of the previous code cell",src:n(92167).A+"",width:"741",height:"1063"})}),"\n",(0,a.jsx)(e.p,{children:"Transpilare ciascuno dei circuiti di permutazione utilizzando i pass di sintesi AI e i metodi di sintesi generici."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'results = []\npm_no_ai_synth = generate_preset_pass_manager(\n    coupling_map=cm,\n    optimization_level=1,  # set to 1 since we are using the synthesis methods\n)\n\n# Transpile and analyze all circuits\nfor i, (qc_name, qc) in enumerate(circuits.items(), start=1):\n    pattern = patterns[i - 1]  # Get the corresponding pattern\n\n    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)\n    qc_basic = synth_permutation_basic(pattern)\n\n    # AI synthesis\n    results.append(\n        synth_transpile_with_metrics(\n            qc.decompose(reps=3),\n            pm_ai,\n            qc_name,\n            "AI",\n        )\n    )\n\n    # Depth-LNN-KMS Method\n    results.append(\n        synth_transpile_with_metrics(\n            qc_depth_lnn_kms.decompose(reps=3),\n            pm_no_ai_synth,\n            qc_name,\n            "Depth-LNN-KMS",\n        )\n    )\n\n    # Basic Method\n    results.append(\n        synth_transpile_with_metrics(\n            qc_basic.decompose(reps=3),\n            pm_no_ai_synth,\n            qc_name,\n            "Basic",\n        )\n    )\n\nresults_df = pd.DataFrame(results)\n'})}),"\n",(0,a.jsx)(e.p,{children:"Registrare le metriche (profondit\xe0, conteggio dei gate, tempo) per ciascun circuito dopo la transpilazione."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Calculate averages for each metric\naverage_metrics = results_df.groupby("Method")[\n    ["Depth (2Q)", "Gates", "Time (s)"]\n].mean()\naverage_metrics = average_metrics.round(3)  # Round to two decimal places\nprint("\\n=== Average Metrics ===")\nprint(average_metrics)\n\n# Identify the best non-AI method based on least average depth\nnon_ai_methods = [\n    method for method in results_df["Method"].unique() if method != "AI"\n]\nbest_non_ai_method = average_metrics.loc[non_ai_methods][\n    "Depth (2Q)"\n].idxmin()\nprint(\n    f"\\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"\n)\n\n# Compare AI to the best non-AI method\nai_metrics = average_metrics.loc["AI"]\nbest_non_ai_metrics = average_metrics.loc[best_non_ai_method]\n\ncomparison = {\n    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],\n    "AI": [\n        ai_metrics["Depth (2Q)"],\n        ai_metrics["Gates"],\n        ai_metrics["Time (s)"],\n    ],\n    best_non_ai_method: [\n        best_non_ai_metrics["Depth (2Q)"],\n        best_non_ai_metrics["Gates"],\n        best_non_ai_metrics["Time (s)"],\n    ],\n    "Improvement (AI vs Best Non-AI)": [\n        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],\n        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],\n        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],\n    ],\n}\n\ncomparison_df = pd.DataFrame(comparison)\nprint("\\n=== Comparison of AI vs Best Non-AI Method ===")\ncomparison_df\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-text",children:"=== Average Metrics ===\n               Depth (2Q)  Gates  Time (s)\nMethod\nAI                   23.9   82.8     0.248\nBasic                29.8   91.0     0.012\nDepth-LNN-KMS        70.8  531.6     0.017\n\nBest Non-AI Method (based on least average depth): Basic\n\n=== Comparison of AI vs Best Non-AI Method ===\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-text",children:"Metric      AI   Basic  Improvement (AI vs Best Non-AI)\n0  Depth (2Q)  23.900  29.800                           -5.900\n1       Gates  82.800  91.000                           -8.200\n2    Time (s)   0.248   0.012                            0.236\n"})}),"\n",(0,a.jsx)(e.p,{children:"I risultati dimostrano che il transpilatore AI supera tutti gli altri metodi di sintesi Qiskit per questo insieme di circuiti di permutazione casuali. I risultati chiave includono:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Profondit\xe0: Il transpilatore AI raggiunge la profondit\xe0 media pi\xf9 bassa, indicando un'ottimizzazione superiore dei layout dei circuiti."}),"\n",(0,a.jsx)(e.li,{children:"Conteggio dei gate: Riduce significativamente il numero di gate rispetto ad altri metodi, migliorando la fedelt\xe0 e l'efficienza dell'esecuzione."}),"\n",(0,a.jsx)(e.li,{children:"Tempo di transpilazione: Tutti i metodi funzionano molto rapidamente a questa scala, rendendoli pratici per l'uso. Tuttavia, il transpilatore AI presenta un aumento notevole del tempo di runtime rispetto ai metodi tradizionali a causa della complessit\xe0 dei modelli AI utilizzati."}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Questi risultati stabiliscono il transpilatore AI come l'approccio pi\xf9 efficace per questo benchmark, in particolare per l'ottimizzazione della profondit\xe0 e del conteggio dei gate.\nTracciare i risultati per confrontare le prestazioni dei pass di sintesi AI rispetto ai metodi di sintesi generici."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'methods = results_df["Method"].unique()\n\nfig, axs = plt.subplots(1, 3, figsize=(18, 5))\n\n# Pivot the DataFrame and reorder columns to ensure AI is first\npivot_depth = results_df.pivot(\n    index="Pattern", columns="Method", values="Depth (2Q)"\n)[["AI", "Depth-LNN-KMS", "Basic"]]\npivot_gates = results_df.pivot(\n    index="Pattern", columns="Method", values="Gates"\n)[["AI", "Depth-LNN-KMS", "Basic"]]\npivot_time = results_df.pivot(\n    index="Pattern", columns="Method", values="Time (s)"\n)[["AI", "Depth-LNN-KMS", "Basic"]]\n\npivot_depth.plot(kind="bar", ax=axs[0], legend=False)\naxs[0].set_title("Circuit Depth Comparison")\naxs[0].set_ylabel("Depth")\naxs[0].set_xlabel("Pattern")\naxs[0].tick_params(axis="x", rotation=45)\npivot_gates.plot(kind="bar", ax=axs[1], legend=False)\naxs[1].set_title("2Q Gate Count Comparison")\naxs[1].set_ylabel("Number of 2Q Gates")\naxs[1].set_xlabel("Pattern")\naxs[1].set_xlabel("Pattern")\naxs[1].tick_params(axis="x", rotation=45)\npivot_time.plot(\n    kind="bar", ax=axs[2], legend=True, title="Legend"\n)  # Show legend on the last plot\naxs[2].set_title("Time Comparison")\naxs[2].set_ylabel("Time (seconds)")\naxs[2].set_xlabel("Pattern")\naxs[2].tick_params(axis="x", rotation=45)\nfig.suptitle(\n    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",\n    fontsize=16,\n    y=1,\n)\n\nplt.tight_layout()\nplt.show()\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{alt:"Output of the previous code cell",src:n(9020).A+"",width:"1790",height:"505"})}),"\n",(0,a.jsxs)(e.p,{children:["Questo grafico evidenzia i risultati individuali per ciascun circuito (da ",(0,a.jsx)(e.code,{children:"qc_1"})," a ",(0,a.jsx)(e.code,{children:"qc_10"}),") attraverso diversi metodi di sintesi:"]}),"\n",(0,a.jsx)(e.p,{children:"Sebbene questi risultati sottolineino l'efficacia del transpilatore AI per i circuiti di permutazione, \xe8 importante notare le sue limitazioni. Il metodo di sintesi AI \xe8 attualmente disponibile solo per determinate mappe di accoppiamento, il che potrebbe limitarne l'applicabilit\xe0 pi\xf9 ampia. Questo vincolo dovrebbe essere considerato quando si valuta il suo utilizzo in scenari diversi."}),"\n",(0,a.jsx)(e.p,{children:"Nel complesso, il transpilatore AI dimostra miglioramenti promettenti nell'ottimizzazione della profondit\xe0 e del conteggio dei gate per questi circuiti specifici, mantenendo tempi di transpilazione comparabili."}),"\n",(0,a.jsx)(e.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Step 3: Eseguire utilizzando le primitive di Qiskit"}),"\n",(0,a.jsx)(e.p,{children:"Poich\xe9 questo tutorial si concentra sulla transpilazione, non verranno eseguiti esperimenti sul dispositivo quantistico. L'obiettivo \xe8 sfruttare le ottimizzazioni dello Step 2 per ottenere un circuito transpilato con profondit\xe0 o conteggio dei gate ridotti."}),"\n",(0,a.jsx)(e.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Step 4: Post-elaborare e restituire il risultato nel formato classico desiderato"}),"\n",(0,a.jsx)(e.p,{children:"Poich\xe9 non c'\xe8 esecuzione per questo notebook, non ci sono risultati da post-elaborare."}),"\n",(0,a.jsx)(e.h2,{id:"tutorial-survey",children:"Sondaggio del tutorial"}),"\n",(0,a.jsx)(e.p,{children:"Vi preghiamo di completare questo breve sondaggio per fornire feedback su questo tutorial. Le vostre considerazioni ci aiuteranno a migliorare i nostri contenuti e l'esperienza utente."})]})}function p(i={}){const{wrapper:e}={...(0,s.R)(),...i.components};return e?(0,a.jsx)(e,{...i,children:(0,a.jsx)(d,{...i})}):d(i)}},21504(i,e,n){n.d(e,{A:()=>t});const t=n.p+"assets/images/ai-transpiler-benchmarks-5dfaa6123e5b1fc808af7c936ed6f3ba.avif"},40641(i,e,n){n.d(e,{A:()=>t});const t=n.p+"assets/images/76a3e847-0808-4413-bd0c-c760cd2df3f4-0-0d3034cfa9815f5f2b9fd1f420c7787c.avif"},69619(i,e,n){n.d(e,{A:()=>t});const t=n.p+"assets/images/79b8d5d9-0f9d-42ca-9583-8bec17430014-0-d31e14763e64049ac4420180296979b8.avif"},92167(i,e,n){n.d(e,{A:()=>t});const t=n.p+"assets/images/84dff2c2-a496-4828-bb8e-08d373816a36-0-7f6cdedf900501e41bf594e30d1992a7.avif"},9020(i,e,n){n.d(e,{A:()=>t});const t=n.p+"assets/images/a326f268-0115-442c-8563-968676b66670-0-fcfe131dcc0450bf01804ee4bbd3492a.avif"},90654(i,e,n){n.d(e,{A:()=>t});const t="data:image/avif;base64,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"},28453(i,e,n){n.d(e,{R:()=>r,x:()=>o});var t=n(96540);const a={},s=t.createContext(a);function r(i){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function o(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(a):i.components||a:r(i.components),t.createElement(s.Provider,{value:e},i.children)}}}]);