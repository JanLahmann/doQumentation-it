"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[4835],{37669(i,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"tutorials/combine-error-mitigation-techniques","title":"Combinare opzioni di mitigazione degli errori con la primitiva Estimator","description":"Combinate opzioni di mitigazione degli errori per esperimenti su scala di utilit\xe0 usando QPU IBM Quantum da 100Q+ e la primitiva Estimator di Qiskit Runtime.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/combine-error-mitigation-techniques.mdx","sourceDirName":"tutorials","slug":"/tutorials/combine-error-mitigation-techniques","permalink":"/tutorials/combine-error-mitigation-techniques","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/combine-error-mitigation-techniques.mdx","tags":[],"version":"current","frontMatter":{"title":"Combinare opzioni di mitigazione degli errori con la primitiva Estimator","sidebar_label":"Combinare opzioni di mitigazione degli errori con la primitiva Estimator","description":"Combinate opzioni di mitigazione degli errori per esperimenti su scala di utilit\xe0 usando QPU IBM Quantum da 100Q+ e la primitiva Estimator di Qiskit Runtime.","notebook_path":"docs/tutorials/combine-error-mitigation-techniques.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Mitigazione degli errori su scala industriale con amplificazione probabilistica dell\'errore","permalink":"/tutorials/probabilistic-error-amplification"},"next":{"title":"Benchmarking in tempo reale per la selezione dei qubit","permalink":"/tutorials/real-time-benchmarking-for-qubit-selection"}}');var s=t(74848),n=t(28453);const r={title:"Combinare opzioni di mitigazione degli errori con la primitiva Estimator",sidebar_label:"Combinare opzioni di mitigazione degli errori con la primitiva Estimator",description:"Combinate opzioni di mitigazione degli errori per esperimenti su scala di utilit\xe0 usando QPU IBM Quantum da 100Q+ e la primitiva Estimator di Qiskit Runtime.",notebook_path:"docs/tutorials/combine-error-mitigation-techniques.ipynb"},o=void 0,l={},c=[{value:"Contesto",id:"background",level:2},{value:"Requisiti",id:"requirements",level:2},{value:"Setup",id:"setup",level:2},{value:"Passo 1: Mappare input classici a un problema quantistico",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Circuito specchiato",id:"mirror-circuit",level:4},{value:"Passo 2: Ottimizzare il problema per l&#39;esecuzione su hardware quantistico",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Passo 3: Eseguire utilizzando le primitive Qiskit",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Passo 4: Post-elaborare e restituire il risultato nel formato classico desiderato",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Scalare l&#39;esperimento",id:"scale-the-experiment-up",level:2},{value:"Conclusione",id:"conclusion",level:2}];function u(i){const e={a:"a",annotation:"annotation",code:"code",em:"em",h2:"h2",h4:"h4",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",msqrt:"msqrt",msub:"msub",p:"p",path:"path",pre:"pre",semantics:"semantics",span:"span",svg:"svg",ul:"ul",...(0,n.R)(),...i.components},{OpenInLabBanner:a}=e;return a||function(i,e){throw new Error("Expected "+(e?"component":"object")+" `"+i+"` to be defined: you likely forgot to import, pass, or provide it.")}("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(a,{notebookPath:"docs/tutorials/combine-error-mitigation-techniques.ipynb"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.em,{children:"Stima di utilizzo: Sette minuti su un processore Heron r2 (NOTA: Questa \xe8 solo una stima. Il vostro tempo di esecuzione potrebbe variare.)"})}),"\n",(0,s.jsx)(e.h2,{id:"background",children:"Contesto"}),"\n",(0,s.jsx)(e.p,{children:"Questa guida esplora le opzioni di soppressione e mitigazione degli errori disponibili con la primitiva Estimator di Qiskit Runtime. Costruirete un circuito e un osservabile e sottometterete job utilizzando la primitiva Estimator con diverse combinazioni di impostazioni di mitigazione degli errori. Quindi, traccerete i risultati per osservare gli effetti delle varie impostazioni. La maggior parte degli esempi utilizza un circuito a 10 qubit per rendere pi\xf9 facili le visualizzazioni, e alla fine potrete scalare il workflow fino a 50 qubit."}),"\n",(0,s.jsx)(e.p,{children:"Queste sono le opzioni di soppressione e mitigazione degli errori che utilizzerete:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Disaccoppiamento dinamico"}),"\n",(0,s.jsx)(e.li,{children:"Mitigazione degli errori di misura"}),"\n",(0,s.jsx)(e.li,{children:"Gate twirling"}),"\n",(0,s.jsx)(e.li,{children:"Estrapolazione a rumore zero (ZNE)"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"requirements",children:"Requisiti"}),"\n",(0,s.jsx)(e.p,{children:"Prima di iniziare questa guida, assicuratevi di avere installato quanto segue:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Qiskit SDK v2.1 o successivo, con supporto per la ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualizzazione"})]}),"\n",(0,s.jsxs)(e.li,{children:["Qiskit Runtime v0.40 o successivo (",(0,s.jsx)(e.code,{children:"pip install qiskit-ibm-runtime"}),")"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import matplotlib.pyplot as plt\nimport numpy as np\n\nfrom qiskit.circuit.library import efficient_su2, unitary_overlap\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import Batch, EstimatorV2 as Estimator\n"})}),"\n",(0,s.jsx)(e.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Passo 1: Mappare input classici a un problema quantistico"}),"\n",(0,s.jsxs)(e.p,{children:["Questa guida assume che il problema classico sia gi\xe0 stato mappato in forma quantistica. Iniziate costruendo un circuito e un osservabile da misurare. Sebbene le tecniche qui utilizzate si applichino a molti tipi diversi di circuiti, per semplicit\xe0 questa guida utilizza il circuito ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.efficient_su2",children:(0,s.jsx)(e.code,{children:"efficient_su2"})})," incluso nella libreria di circuiti di Qiskit."]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"efficient_su2"})," \xe8 un circuito quantistico parametrizzato progettato per essere eseguito in modo efficiente su hardware quantistico con connettivit\xe0 limitata dei qubit, pur essendo sufficientemente espressivo per risolvere problemi in domini applicativi come l'ottimizzazione e la chimica. \xc8 costruito alternando strati di gate parametrizzati a singolo qubit con uno strato contenente un pattern fisso di gate a due qubit, per un numero scelto di ripetizioni. Il pattern di gate a due qubit pu\xf2 essere specificato dall'utente. Qui potete utilizzare il pattern integrato ",(0,s.jsx)(e.code,{children:"pairwise"})," perch\xe9 minimizza la profondit\xe0 del circuito impacchettando i gate a due qubit nel modo pi\xf9 denso possibile. Questo pattern pu\xf2 essere eseguito utilizzando solo connettivit\xe0 lineare dei qubit."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'n_qubits = 10\nreps = 1\n\ncircuit = efficient_su2(n_qubits, entanglement="pairwise", reps=reps)\n\ncircuit.decompose().draw("mpl", scale=0.7)\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(20771).A+"",width:"1713",height:"499"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(28628).A+"",width:"1713",height:"499"})}),"\n",(0,s.jsxs)(e.p,{children:["Per il nostro osservabile, prendiamo l'operatore di Pauli ",(0,s.jsxs)(e.span,{className:"katex",children:[(0,s.jsx)(e.span,{className:"katex-mathml",children:(0,s.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(e.semantics,{children:[(0,s.jsx)(e.mrow,{children:(0,s.jsx)(e.mi,{children:"Z"})}),(0,s.jsx)(e.annotation,{encoding:"application/x-tex",children:"Z"})]})})}),(0,s.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(e.span,{className:"base",children:[(0,s.jsx)(e.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"})]})})]})," che agisce sull'ultimo qubit, ",(0,s.jsxs)(e.span,{className:"katex",children:[(0,s.jsx)(e.span,{className:"katex-mathml",children:(0,s.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(e.semantics,{children:[(0,s.jsxs)(e.mrow,{children:[(0,s.jsx)(e.mi,{children:"Z"}),(0,s.jsx)(e.mi,{children:"I"}),(0,s.jsx)(e.mo,{children:"\u22ef"}),(0,s.jsx)(e.mi,{children:"I"})]}),(0,s.jsx)(e.annotation,{encoding:"application/x-tex",children:"Z I \\cdots I"})]})})}),(0,s.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(e.span,{className:"base",children:[(0,s.jsx)(e.span,{className:"strut",style:{height:"0.6833em"}}),(0,s.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"}),(0,s.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.07847em"},children:"I"}),(0,s.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(e.span,{className:"minner",children:"\u22ef"}),(0,s.jsx)(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,s.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.07847em"},children:"I"})]})})]}),"."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# Z on the last qubit (index -1) with coefficient 1.0\nobservable = SparsePauliOp.from_sparse_list(\n    [("Z", [-1], 1.0)], num_qubits=n_qubits\n)\n'})}),"\n",(0,s.jsx)(e.p,{children:'A questo punto, potreste procedere a eseguire il vostro circuito e misurare l\'osservabile. Tuttavia, volete anche confrontare l\'output del dispositivo quantistico con la risposta corretta - cio\xe8, il valore teorico dell\'osservabile, se il circuito fosse stato eseguito senza errori. Per circuiti quantistici piccoli potete calcolare questo valore simulando il circuito su un computer classico, ma questo non \xe8 possibile per circuiti pi\xf9 grandi, su scala di utilit\xe0. Potete aggirare questo problema con la tecnica del "circuito specchiato" (nota anche come "compute-uncompute"), che \xe8 utile per il benchmarking delle prestazioni dei dispositivi quantistici.'}),"\n",(0,s.jsx)(e.h4,{id:"mirror-circuit",children:"Circuito specchiato"}),"\n",(0,s.jsx)(e.p,{children:"Nella tecnica del circuito specchiato, concatenate il circuito con il suo circuito inverso, che \xe8 formato invertendo ciascun gate del circuito in ordine inverso. Il circuito risultante implementa l'operatore identit\xe0, che pu\xf2 essere simulato in modo banale. Poich\xe9 la struttura del circuito originale \xe8 preservata nel circuito specchiato, eseguire il circuito specchiato d\xe0 comunque un'idea di come il dispositivo quantistico si comporterebbe sul circuito originale."}),"\n",(0,s.jsxs)(e.p,{children:["La seguente cella di codice assegna parametri casuali al vostro circuito, e quindi costruisce il circuito specchiato utilizzando la classe ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.unitary_overlap",children:(0,s.jsx)(e.code,{children:"unitary_overlap"})}),". Prima di specchiare il circuito, aggiungete un'istruzione ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/circuit#qiskit.circuit.Barrier",children:"barrier"})," ad esso per impedire al transpiler di fondere le due parti del circuito su entrambi i lati della barriera. Senza la barriera, il transpiler fonderebbe il circuito originale con il suo inverso, risultando in un circuito traspilato senza alcun gate."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# Generate random parameters\nrng = np.random.default_rng(1234)\nparams = rng.uniform(-np.pi, np.pi, size=circuit.num_parameters)\n\n# Assign the parameters to the circuit\nassigned_circuit = circuit.assign_parameters(params)\n\n# Add a barrier to prevent circuit optimization of mirrored operators\nassigned_circuit.barrier()\n\n# Construct mirror circuit\nmirror_circuit = unitary_overlap(assigned_circuit, assigned_circuit)\n\nmirror_circuit.decompose().draw("mpl", scale=0.7)\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(89975).A+"",width:"941",height:"500"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(86472).A+"",width:"941",height:"500"})}),"\n",(0,s.jsx)(e.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Passo 2: Ottimizzare il problema per l'esecuzione su hardware quantistico"}),"\n",(0,s.jsx)(e.p,{children:"Dovete ottimizzare il vostro circuito prima di eseguirlo sull'hardware. Questo processo comporta alcuni passi:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Scegliere un layout di qubit che mappi i qubit virtuali del vostro circuito ai qubit fisici sull'hardware."}),"\n",(0,s.jsx)(e.li,{children:"Inserire gate di swap secondo necessit\xe0 per instradare interazioni tra qubit che non sono connessi."}),"\n",(0,s.jsxs)(e.li,{children:["Tradurre i gate nel vostro circuito in istruzioni ",(0,s.jsx)(e.a,{href:"/guides/transpile#instruction-set-architecture",children:"Instruction Set Architecture (ISA)"})," che possono essere eseguite direttamente sull'hardware."]}),"\n",(0,s.jsx)(e.li,{children:"Eseguire ottimizzazioni del circuito per minimizzare la profondit\xe0 del circuito e il conteggio dei gate."}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Il transpiler integrato in Qiskit pu\xf2 eseguire tutti questi passi per voi. Poich\xe9 questo esempio utilizza un circuito hardware-efficient, il transpiler dovrebbe essere in grado di scegliere un layout di qubit che non richieda l'inserimento di alcun gate di swap per l'instradamento delle interazioni."}),"\n",(0,s.jsx)(e.p,{children:"Dovete scegliere il dispositivo hardware da utilizzare prima di ottimizzare il vostro circuito. La seguente cella di codice richiede il dispositivo meno occupato con almeno 127 qubit."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"service = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=127\n)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Potete traspilare il vostro circuito per il vostro backend scelto creando un pass manager e quindi eseguendo il pass manager sul circuito. Un modo semplice per creare un pass manager \xe8 utilizzare la funzione ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager",children:(0,s.jsx)(e.code,{children:"generate_preset_pass_manager"})}),". Consultate ",(0,s.jsx)(e.a,{href:"/guides/transpile-with-pass-managers",children:"Transpile with pass managers"})," per una spiegazione pi\xf9 dettagliata della traspilazione con i pass manager."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'pass_manager = generate_preset_pass_manager(\n    optimization_level=3, backend=backend, seed_transpiler=1234\n)\nisa_circuit = pass_manager.run(mirror_circuit)\n\nisa_circuit.draw("mpl", idle_wires=False, scale=0.7, fold=-1)\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(73284).A+"",width:"1529",height:"501"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(82643).A+"",width:"1529",height:"501"})}),"\n",(0,s.jsxs)(e.p,{children:["Il circuito traspilato ora contiene solo istruzioni ISA. I gate a singolo qubit sono stati decomposti in termini di gate ",(0,s.jsxs)(e.span,{className:"katex",children:[(0,s.jsx)(e.span,{className:"katex-mathml",children:(0,s.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(e.semantics,{children:[(0,s.jsx)(e.mrow,{children:(0,s.jsx)(e.msqrt,{children:(0,s.jsx)(e.mi,{children:"X"})})}),(0,s.jsx)(e.annotation,{encoding:"application/x-tex",children:"\\sqrt{X}"})]})})}),(0,s.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(e.span,{className:"base",children:[(0,s.jsx)(e.span,{className:"strut",style:{height:"1.04em",verticalAlign:"-0.1133em"}}),(0,s.jsx)(e.span,{className:"mord sqrt",children:(0,s.jsxs)(e.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(e.span,{className:"vlist-r",children:[(0,s.jsxs)(e.span,{className:"vlist",style:{height:"0.9267em"},children:[(0,s.jsxs)(e.span,{className:"svg-align",style:{top:"-3em"},children:[(0,s.jsx)(e.span,{className:"pstrut",style:{height:"3em"}}),(0,s.jsx)(e.span,{className:"mord",style:{paddingLeft:"0.833em"},children:(0,s.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.07847em"},children:"X"})})]}),(0,s.jsxs)(e.span,{style:{top:"-2.8867em"},children:[(0,s.jsx)(e.span,{className:"pstrut",style:{height:"3em"}}),(0,s.jsx)(e.span,{className:"hide-tail",style:{minWidth:"0.853em",height:"1.08em"},children:(0,s.jsx)(e.svg,{xmlns:"http://www.w3.org/2000/svg",width:"400em",height:"1.08em",viewBox:"0 0 400000 1080",preserveAspectRatio:"xMinYMin slice",children:(0,s.jsx)(e.path,{d:"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z"})})})]})]}),(0,s.jsx)(e.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(e.span,{className:"vlist-r",children:(0,s.jsx)(e.span,{className:"vlist",style:{height:"0.1133em"},children:(0,s.jsx)(e.span,{})})})]})})]})})]})," e rotazioni ",(0,s.jsxs)(e.span,{className:"katex",children:[(0,s.jsx)(e.span,{className:"katex-mathml",children:(0,s.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(e.semantics,{children:[(0,s.jsx)(e.mrow,{children:(0,s.jsxs)(e.msub,{children:[(0,s.jsx)(e.mi,{children:"R"}),(0,s.jsx)(e.mi,{children:"z"})]})}),(0,s.jsx)(e.annotation,{encoding:"application/x-tex",children:"R_z"})]})})}),(0,s.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(e.span,{className:"base",children:[(0,s.jsx)(e.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,s.jsxs)(e.span,{className:"mord",children:[(0,s.jsx)(e.span,{className:"mord mathnormal",style:{marginRight:"0.00773em"},children:"R"}),(0,s.jsx)(e.span,{className:"msupsub",children:(0,s.jsxs)(e.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(e.span,{className:"vlist-r",children:[(0,s.jsx)(e.span,{className:"vlist",style:{height:"0.1514em"},children:(0,s.jsxs)(e.span,{style:{top:"-2.55em",marginLeft:"-0.0077em",marginRight:"0.05em"},children:[(0,s.jsx)(e.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(e.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(e.span,{className:"mord mathnormal mtight",style:{marginRight:"0.04398em"},children:"z"})})]})}),(0,s.jsx)(e.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(e.span,{className:"vlist-r",children:(0,s.jsx)(e.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(e.span,{})})})]})})]})]})})]}),", e i gate CX sono stati decomposti in ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate#ecrgate",children:"gate ECR"})," e rotazioni a singolo qubit."]}),"\n",(0,s.jsxs)(e.p,{children:["Il processo di traspilazione ha mappato i qubit virtuali del circuito ai qubit fisici sull'hardware. Le informazioni sul layout dei qubit sono memorizzate nell'attributo ",(0,s.jsx)(e.code,{children:"layout"})," del circuito traspilato. Anche l'osservabile \xe8 stato definito in termini di qubit virtuali, quindi dovete applicare questo layout all'osservabile, cosa che potete fare con il metodo ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.SparsePauliOp#apply_layout",children:(0,s.jsx)(e.code,{children:"apply_layout"})})," di ",(0,s.jsx)(e.code,{children:"SparsePauliOp"}),"."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'isa_observable = observable.apply_layout(isa_circuit.layout)\n\nprint("Original observable:")\nprint(observable)\nprint()\nprint("Observable with layout applied:")\nprint(isa_observable)\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-text",children:"Original observable:\nSparsePauliOp(['ZIIIIIIIII'],\n              coeffs=[1.+0.j])\n\nObservable with layout applied:\nSparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII'],\n              coeffs=[1.+0.j])\n"})}),"\n",(0,s.jsx)(e.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Passo 3: Eseguire utilizzando le primitive Qiskit"}),"\n",(0,s.jsx)(e.p,{children:"Ora siete pronti a eseguire il vostro circuito utilizzando la primitiva Estimator."}),"\n",(0,s.jsx)(e.p,{children:"Qui sottometterete cinque job separati, iniziando senza soppressione o mitigazione degli errori, e abilitando successivamente varie opzioni di soppressione e mitigazione degli errori disponibili in Qiskit Runtime. Per informazioni sulle opzioni, fate riferimento alle seguenti pagine:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options",children:"Panoramica di tutte le opzioni"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-dynamical-decoupling-options",children:"Disaccoppiamento dinamico"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-resilience-options-v2",children:"Resilienza, inclusa la mitigazione degli errori di misura e l'estrapolazione a rumore zero (ZNE)"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-twirling-options",children:"Twirling"})}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Poich\xe9 questi job possono essere eseguiti indipendentemente l'uno dall'altro, potete utilizzare la ",(0,s.jsx)(e.a,{href:"/guides/run-jobs-batch",children:"modalit\xe0 batch"})," per consentire a Qiskit Runtime di ottimizzare la temporizzazione della loro esecuzione."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'pub = (isa_circuit, isa_observable)\n\njobs = []\n\nwith Batch(backend=backend) as batch:\n    estimator = Estimator(mode=batch)\n    # Set number of shots\n    estimator.options.default_shots = 100_000\n    # Disable runtime compilation and error mitigation\n    estimator.options.resilience_level = 0\n\n    # Run job with no error mitigation\n    job0 = estimator.run([pub])\n    jobs.append(job0)\n\n    # Add dynamical decoupling (DD)\n    estimator.options.dynamical_decoupling.enable = True\n    estimator.options.dynamical_decoupling.sequence_type = "XpXm"\n    job1 = estimator.run([pub])\n    jobs.append(job1)\n\n    # Add readout error mitigation (DD + TREX)\n    estimator.options.resilience.measure_mitigation = True\n    job2 = estimator.run([pub])\n    jobs.append(job2)\n\n    # Add gate twirling (DD + TREX + Gate Twirling)\n    estimator.options.twirling.enable_gates = True\n    estimator.options.twirling.num_randomizations = "auto"\n    job3 = estimator.run([pub])\n    jobs.append(job3)\n\n    # Add zero-noise extrapolation (DD + TREX + Gate Twirling + ZNE)\n    estimator.options.resilience.zne_mitigation = True\n    estimator.options.resilience.zne.noise_factors = (1, 3, 5)\n    estimator.options.resilience.zne.extrapolator = ("exponential", "linear")\n    job4 = estimator.run([pub])\n    jobs.append(job4)\n'})}),"\n",(0,s.jsx)(e.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Passo 4: Post-elaborare e restituire il risultato nel formato classico desiderato"}),"\n",(0,s.jsx)(e.p,{children:"Infine, potete analizzare i dati. Qui recupererete i risultati dei job, estrarrete i valori di aspettazione misurati da essi e traccerete i valori, includendo barre di errore di una deviazione standard."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'# Retrieve the job results\nresults = [job.result() for job in jobs]\n\n# Unpack the PUB results (there\'s only one PUB result in each job result)\npub_results = [result[0] for result in results]\n\n# Unpack the expectation values and standard errors\nexpectation_vals = np.array(\n    [float(pub_result.data.evs) for pub_result in pub_results]\n)\nstandard_errors = np.array(\n    [float(pub_result.data.stds) for pub_result in pub_results]\n)\n\n# Plot the expectation values\nfig, ax = plt.subplots()\nlabels = ["No mitigation", "+ DD", "+ TREX", "+ Twirling", "+ ZNE"]\nax.bar(\n    range(len(labels)),\n    expectation_vals,\n    yerr=standard_errors,\n    label="experiment",\n)\nax.axhline(y=1.0, color="gray", linestyle="--", label="ideal")\nax.set_xticks(range(len(labels)))\nax.set_xticklabels(labels)\nax.set_ylabel("Expectation value")\nax.legend(loc="upper left")\n\nplt.show()\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(36884).A+"",width:"567",height:"413"})}),"\n",(0,s.jsx)(e.p,{children:"A questa piccola scala, \xe8 difficile vedere l'effetto della maggior parte delle tecniche di mitigazione degli errori, ma l'estrapolazione a rumore zero fornisce un miglioramento evidente. Tuttavia, notate che questo miglioramento non arriva gratuitamente, perch\xe9 il risultato ZNE ha anche una barra di errore pi\xf9 grande."}),"\n",(0,s.jsx)(e.h2,{id:"scale-the-experiment-up",children:"Scalare l'esperimento"}),"\n",(0,s.jsx)(e.p,{children:"Quando si sviluppa un esperimento, \xe8 utile iniziare con un circuito piccolo per rendere pi\xf9 facili le visualizzazioni e le simulazioni. Ora che avete sviluppato e testato il nostro workflow su un circuito a 10 qubit, potete scalarlo fino a 50 qubit. La seguente cella di codice ripete tutti i passi di questa guida, ma ora li applica a un circuito a 50 qubit."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'n_qubits = 50\nreps = 1\n\n# Construct circuit and observable\ncircuit = efficient_su2(n_qubits, entanglement="pairwise", reps=reps)\nobservable = SparsePauliOp.from_sparse_list(\n    [("Z", [-1], 1.0)], num_qubits=n_qubits\n)\n\n# Assign parameters to circuit\nparams = rng.uniform(-np.pi, np.pi, size=circuit.num_parameters)\nassigned_circuit = circuit.assign_parameters(params)\nassigned_circuit.barrier()\n\n# Construct mirror circuit\nmirror_circuit = unitary_overlap(assigned_circuit, assigned_circuit)\n\n# Transpile circuit and observable\nisa_circuit = pass_manager.run(mirror_circuit)\nisa_observable = observable.apply_layout(isa_circuit.layout)\n\n# Run jobs\npub = (isa_circuit, isa_observable)\n\njobs = []\n\nwith Batch(backend=backend) as batch:\n    estimator = Estimator(mode=batch)\n    # Set number of shots\n    estimator.options.default_shots = 100_000\n    # Disable runtime compilation and error mitigation\n    estimator.options.resilience_level = 0\n\n    # Run job with no error mitigation\n    job0 = estimator.run([pub])\n    jobs.append(job0)\n\n    # Add dynamical decoupling (DD)\n    estimator.options.dynamical_decoupling.enable = True\n    estimator.options.dynamical_decoupling.sequence_type = "XpXm"\n    job1 = estimator.run([pub])\n    jobs.append(job1)\n\n    # Add readout error mitigation (DD + TREX)\n    estimator.options.resilience.measure_mitigation = True\n    job2 = estimator.run([pub])\n    jobs.append(job2)\n\n    # Add gate twirling (DD + TREX + Gate Twirling)\n    estimator.options.twirling.enable_gates = True\n    estimator.options.twirling.num_randomizations = "auto"\n    job3 = estimator.run([pub])\n    jobs.append(job3)\n\n    # Add zero-noise extrapolation (DD + TREX + Gate Twirling + ZNE)\n    estimator.options.resilience.zne_mitigation = True\n    estimator.options.resilience.zne.noise_factors = (1, 3, 5)\n    estimator.options.resilience.zne.extrapolator = ("exponential", "linear")\n    job4 = estimator.run([pub])\n    jobs.append(job4)\n\n# Retrieve the job results\nresults = [job.result() for job in jobs]\n\n# Unpack the PUB results (there\'s only one PUB result in each job result)\npub_results = [result[0] for result in results]\n\n# Unpack the expectation values and standard errors\nexpectation_vals = np.array(\n    [float(pub_result.data.evs) for pub_result in pub_results]\n)\nstandard_errors = np.array(\n    [float(pub_result.data.stds) for pub_result in pub_results]\n)\n\n# Plot the expectation values\nfig, ax = plt.subplots()\nlabels = ["No mitigation", "+ DD", "+ TREX", "+ Twirling", "+ ZNE"]\nax.bar(\n    range(len(labels)),\n    expectation_vals,\n    yerr=standard_errors,\n    label="experiment",\n)\nax.axhline(y=1.0, color="gray", linestyle="--", label="ideal")\nax.set_xticks(range(len(labels)))\nax.set_xticklabels(labels)\nax.set_ylabel("Expectation value")\nax.legend(loc="upper left")\n\nplt.show()\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Output of the previous code cell",src:t(51535).A+"",width:"567",height:"413"})}),"\n",(0,s.jsx)(e.p,{children:"Quando confrontate i risultati a 50 qubit con i risultati a 10 qubit precedenti, potreste notare quanto segue (i vostri risultati potrebbero differire tra le esecuzioni):"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"I risultati senza mitigazione degli errori sono peggiori. Eseguire il circuito pi\xf9 grande comporta l'esecuzione di pi\xf9 gate, quindi ci sono pi\xf9 opportunit\xe0 per gli errori di accumularsi."}),"\n",(0,s.jsx)(e.li,{children:"L'aggiunta del disaccoppiamento dinamico potrebbe aver peggiorato le prestazioni. Questo non \xe8 sorprendente, perch\xe9 il circuito \xe8 molto denso. Il disaccoppiamento dinamico \xe8 principalmente utile quando ci sono grandi lacune nel circuito durante le quali i qubit rimangono inattivi senza che vengano applicati gate. Quando queste lacune non sono presenti, il disaccoppiamento dinamico non \xe8 efficace e pu\xf2 effettivamente peggiorare le prestazioni a causa di errori nei pulse di disaccoppiamento dinamico stessi. Il circuito a 10 qubit potrebbe essere stato troppo piccolo perch\xe9 potessimo osservare questo effetto."}),"\n",(0,s.jsx)(e.li,{children:"Con l'estrapolazione a rumore zero, il risultato \xe8 buono quanto, o quasi quanto, il risultato a 10 qubit, sebbene la barra di errore sia molto pi\xf9 grande. Questo dimostra la potenza della tecnica ZNE!"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"conclusion",children:"Conclusione"}),"\n",(0,s.jsx)(e.p,{children:"In questa guida, avete investigato diverse opzioni di mitigazione degli errori disponibili per la primitiva Estimator di Qiskit Runtime. Avete sviluppato un workflow utilizzando un circuito a 10 qubit, e quindi l'avete scalato fino a 50 qubit. Potreste aver osservato che abilitare pi\xf9 opzioni di soppressione e mitigazione degli errori non migliora sempre le prestazioni (in particolare, l'abilitazione del disaccoppiamento dinamico in questo caso). La maggior parte delle opzioni accetta configurazione aggiuntiva, che potete testare nel vostro lavoro!"})]})}function p(i={}){const{wrapper:e}={...(0,n.R)(),...i.components};return e?(0,s.jsx)(e,{...i,children:(0,s.jsx)(u,{...i})}):u(i)}},73284(i,e,t){t.d(e,{A:()=>a});const a=t.p+"assets/images/027e829a-44d3-455e-b2bf-8ce0d7e26b9b-0-09e70fabe84a4b52cb5379b24886fb7d.avif"},82643(i,e,t){t.d(e,{A:()=>a});const a=t.p+"assets/images/027e829a-44d3-455e-b2bf-8ce0d7e26b9b-1-09e70fabe84a4b52cb5379b24886fb7d.avif"},20771(i,e,t){t.d(e,{A:()=>a});const a=t.p+"assets/images/24abd7ba-bbb8-443b-9e81-866795d39a6c-0-752b3b36e79fe72c8a1da54c52469ac2.avif"},28628(i,e,t){t.d(e,{A:()=>a});const a=t.p+"assets/images/24abd7ba-bbb8-443b-9e81-866795d39a6c-1-752b3b36e79fe72c8a1da54c52469ac2.avif"},89975(i,e,t){t.d(e,{A:()=>a});const a=t.p+"assets/images/4dbde811-1ba9-47a8-85a0-dcaff054ed60-0-e2f658495efb564a698ac04e9096db89.avif"},86472(i,e,t){t.d(e,{A:()=>a});const a=t.p+"assets/images/4dbde811-1ba9-47a8-85a0-dcaff054ed60-1-e2f658495efb564a698ac04e9096db89.avif"},51535(i,e,t){t.d(e,{A:()=>a});const a="data:image/avif;base64,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"},36884(i,e,t){t.d(e,{A:()=>a});const a="data:image/avif;base64,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"},28453(i,e,t){t.d(e,{R:()=>r,x:()=>o});var a=t(96540);const s={},n=a.createContext(s);function r(i){const e=a.useContext(n);return a.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function o(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(s):i.components||s:r(i.components),a.createElement(n.Provider,{value:e},i.children)}}}]);