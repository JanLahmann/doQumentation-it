"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[4756],{43111(e,i,s){s.r(i),s.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"tutorials/real-time-benchmarking-for-qubit-selection","title":"Benchmarking in tempo reale per la selezione dei qubit","description":"Eseguite esperimenti di caratterizzazione in tempo reale e aggiornate le propriet\xe0 del backend per migliorare la selezione dei qubit quando mappate un circuito sui qubit fisici di una QPU.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/real-time-benchmarking-for-qubit-selection.mdx","sourceDirName":"tutorials","slug":"/tutorials/real-time-benchmarking-for-qubit-selection","permalink":"/tutorials/real-time-benchmarking-for-qubit-selection","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/real-time-benchmarking-for-qubit-selection.mdx","tags":[],"version":"current","frontMatter":{"title":"Benchmarking in tempo reale per la selezione dei qubit","sidebar_label":"Benchmarking in tempo reale per la selezione dei qubit","description":"Eseguite esperimenti di caratterizzazione in tempo reale e aggiornate le propriet\xe0 del backend per migliorare la selezione dei qubit quando mappate un circuito sui qubit fisici di una QPU.","notebook_path":"docs/tutorials/real-time-benchmarking-for-qubit-selection.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Combinare opzioni di mitigazione degli errori con la primitiva Estimator","permalink":"/tutorials/combine-error-mitigation-techniques"},"next":{"title":"Codici di ripetizione","permalink":"/tutorials/repetition-codes"}}');var n=s(74848),t=s(28453);const r={title:"Benchmarking in tempo reale per la selezione dei qubit",sidebar_label:"Benchmarking in tempo reale per la selezione dei qubit",description:"Eseguite esperimenti di caratterizzazione in tempo reale e aggiornate le propriet\xe0 del backend per migliorare la selezione dei qubit quando mappate un circuito sui qubit fisici di una QPU.",notebook_path:"docs/tutorials/real-time-benchmarking-for-qubit-selection.ipynb"},l=void 0,o={},c=[{value:"Background",id:"background",level:2},{value:"Requisiti",id:"requirements",level:2},{value:"Setup",id:"setup",level:2},{value:"Step 1: Mappare gli input classici a un problema quantistico",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Configurare il backend e la mappa di accoppiamento",id:"set-up-backend-and-coupling-map",level:3},{value:"Esperimenti di caratterizzazione",id:"characterization-experiments",level:3},{value:"T1",id:"t1",level:4},{value:"T2",id:"t2",level:4},{value:"Caratterizzazione dell&#39;errore di preparazione dello stato e misurazione (SPAM)",id:"state-preparation-and-measurement-spam-error-characterization",level:4},{value:"Randomized benchmarking a singolo qubit e a due qubit",id:"single-qubit-and-two-qubit-randomized-benchmarking",level:4},{value:"Propriet\xe0 della QPU nel tempo",id:"qpu-properties-over-time",level:3},{value:"Step 2: Ottimizzare il problema per l&#39;esecuzione su hardware quantistico",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Step 3: Eseguire utilizzando le primitive Qiskit",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Eseguire un circuito quantistico con la selezione predefinita dei qubit",id:"execute-a-quantum-circuit-with-default-qubit-selection",level:3},{value:"Eseguire un circuito quantistico con selezione dei qubit in tempo reale",id:"execute-a-quantum-circuit-with-real-time-qubit-selection",level:3},{value:"Step 4: Post-processare e restituire il risultato nel formato classico desiderato",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Tutorial survey",id:"tutorial-survey",level:2}];function d(e){const i={a:"a",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mfrac:"mfrac",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,t.R)(),...e.components},{Admonition:a,OpenInLabBanner:r}=i;return a||p("Admonition",!0),r||p("OpenInLabBanner",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r,{notebookPath:"docs/tutorials/real-time-benchmarking-for-qubit-selection.ipynb"}),"\n","\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.em,{children:"Stima di utilizzo: 4 minuti su un processore Eagle r2 (NOTA: Questa \xe8 solo una stima. Il vostro tempo di esecuzione potrebbe variare.)"})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-experiments\n"})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"# This cell is hidden from users \u2013 it disables some lint rules\n# ruff: noqa: E722\n"})}),"\n",(0,n.jsx)(i.h2,{id:"background",children:"Background"}),"\n",(0,n.jsx)(i.p,{children:"Questo tutorial mostra come eseguire esperimenti di caratterizzazione in tempo reale e aggiornare le propriet\xe0 del backend per migliorare la selezione dei qubit quando si mappa un circuito sui qubit fisici di una QPU. Imparerete gli esperimenti di caratterizzazione di base che vengono utilizzati per determinare le propriet\xe0 della QPU, come eseguirli in Qiskit e come aggiornare le propriet\xe0 salvate nell'oggetto backend che rappresenta la QPU in base a questi esperimenti."}),"\n",(0,n.jsxs)(i.p,{children:["Le propriet\xe0 riportate dalla QPU vengono aggiornate una volta al giorno, ma il sistema pu\xf2 derivare pi\xf9 velocemente del tempo che intercorre tra gli aggiornamenti. Questo pu\xf2 influire sull'affidabilit\xe0 delle routine di selezione dei qubit nella fase ",(0,n.jsx)(i.code,{children:"Layout"})," del pass manager, poich\xe9 utilizzerebbero propriet\xe0 riportate che non rappresentano lo stato attuale della QPU. Per questo motivo, pu\xf2 valere la pena dedicare del tempo di QPU agli esperimenti di caratterizzazione, che possono poi essere utilizzati per aggiornare le propriet\xe0 della QPU utilizzate dalla routine ",(0,n.jsx)(i.code,{children:"Layout"}),"."]}),"\n",(0,n.jsx)(i.h2,{id:"requirements",children:"Requisiti"}),"\n",(0,n.jsx)(i.p,{children:"Prima di iniziare questo tutorial, assicuratevi di avere installato quanto segue:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Qiskit SDK v2.0 o successivo, con supporto per la ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualizzazione"})]}),"\n",(0,n.jsxs)(i.li,{children:["Qiskit Runtime v0.40 o successivo ( ",(0,n.jsx)(i.code,{children:"pip install qiskit-ibm-runtime"})," )"]}),"\n",(0,n.jsxs)(i.li,{children:["Qiskit Experiments v0.12 o successivo ( ",(0,n.jsx)(i.code,{children:"pip install qiskit-experiments"})," )"]}),"\n",(0,n.jsxs)(i.li,{children:["Libreria di grafi Rustworkx (",(0,n.jsx)(i.code,{children:"pip install rustworkx"}),")"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"setup",children:"Setup"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import SamplerV2\nfrom qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit.quantum_info import hellinger_fidelity\nfrom qiskit.transpiler import InstructionProperties\n\nfrom qiskit_experiments.library import (\n    T1,\n    T2Hahn,\n    LocalReadoutError,\n    StandardRB,\n)\nfrom qiskit_experiments.framework import BatchExperiment, ParallelExperiment\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import Session\n\nfrom datetime import datetime\nfrom collections import defaultdict\nimport numpy as np\nimport rustworkx\nimport matplotlib.pyplot as plt\nimport copy\n"})}),"\n",(0,n.jsx)(i.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Step 1: Mappare gli input classici a un problema quantistico"}),"\n",(0,n.jsx)(i.p,{children:"Per confrontare le differenze di prestazioni, consideriamo un circuito che prepara uno stato di Bell attraverso una catena lineare di lunghezza variabile. Viene misurata la fedelt\xe0 dello stato di Bell alle estremit\xe0 della catena."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'from qiskit import QuantumCircuit\n\nideal_dist = {"00": 0.5, "11": 0.5}\n\nnum_qubits_list = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 127]\ncircuits = []\nfor num_qubits in num_qubits_list:\n    circuit = QuantumCircuit(num_qubits, 2)\n    circuit.h(0)\n    for i in range(num_qubits - 1):\n        circuit.cx(i, i + 1)\n    circuit.barrier()\n    circuit.measure(0, 0)\n    circuit.measure(num_qubits - 1, 1)\n    circuits.append(circuit)\n\ncircuits[-1].draw(output="mpl", style="clifford", fold=-1)\n'})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Output of the previous code cell",src:s(76086).A+"",width:"8510",height:"8286"})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Output of the previous code cell",src:s(70917).A+"",width:"8510",height:"8286"})}),"\n",(0,n.jsx)(i.h3,{id:"set-up-backend-and-coupling-map",children:"Configurare il backend e la mappa di accoppiamento"}),"\n",(0,n.jsx)(i.p,{children:"Prima di tutto, selezionate un backend"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"# To run on hardware, select the backend with the fewest number of jobs in the queue\nservice = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=127\n)\n\nqubits = list(range(backend.num_qubits))\n"})}),"\n",(0,n.jsx)(i.p,{children:"Quindi ottenete la sua mappa di accoppiamento"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"coupling_graph = backend.coupling_map.graph.to_undirected(multigraph=False)\n\n# Get unidirectional coupling map\none_dir_coupling_map = coupling_graph.edge_list()\n"})}),"\n",(0,n.jsxs)(i.p,{children:["Per sottoporre a benchmark il maggior numero possibile di porte a due qubit simultaneamente, separiamo la mappa di accoppiamento in una ",(0,n.jsx)(i.code,{children:"layered_coupling_map"}),". Questo oggetto contiene un elenco di layer in cui ogni layer \xe8 un elenco di archi sui quali le porte a due qubit possono essere eseguite contemporaneamente. Questa operazione \xe8 anche chiamata colorazione degli archi della mappa di accoppiamento."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"# Get layered coupling map\nedge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)\nlayered_coupling_map = defaultdict(list)\nfor edge_idx, color in edge_coloring.items():\n    layered_coupling_map[color].append(\n        coupling_graph.get_edge_endpoints_by_index(edge_idx)\n    )\nlayered_coupling_map = [\n    sorted(layered_coupling_map[i])\n    for i in sorted(layered_coupling_map.keys())\n]\n"})}),"\n",(0,n.jsx)(i.h3,{id:"characterization-experiments",children:"Esperimenti di caratterizzazione"}),"\n",(0,n.jsxs)(i.p,{children:["Una serie di esperimenti viene utilizzata per caratterizzare le propriet\xe0 principali dei qubit in una QPU. Queste sono ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"1"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]}),", ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"2"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]}),", l'errore di lettura e l'errore delle porte a singolo qubit e a due qubit. Riassumeremo brevemente quali sono queste propriet\xe0 e faremo riferimento agli esperimenti nel pacchetto ",(0,n.jsx)(i.a,{href:"https://qiskit-community.github.io/qiskit-experiments/index.html",children:(0,n.jsx)(i.code,{children:"qiskit-experiments"})})," che vengono utilizzati per caratterizzarle."]}),"\n",(0,n.jsx)(i.h4,{id:"t1",children:"T1"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"1"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]})," \xe8 il tempo caratteristico necessario affinch\xe9 un qubit eccitato decada allo stato fondamentale a causa di processi di decoerenza da smorzamento dell'ampiezza. In un ",(0,n.jsxs)(i.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/characterization/t1.html",children:["esperimento ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"1"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]})]}),", misuriamo un qubit eccitato dopo un ritardo. Maggiore \xe8 il tempo di ritardo, pi\xf9 \xe8 probabile che il qubit decada allo stato fondamentale. L'obiettivo dell'esperimento \xe8 caratterizzare il tasso di decadimento del qubit verso lo stato fondamentale."]}),"\n",(0,n.jsx)(i.h4,{id:"t2",children:"T2"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"2"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]})," rappresenta la quantit\xe0 di tempo necessaria affinch\xe9 la proiezione del vettore di Bloch di un singolo qubit sul piano XY decada a circa il 37% (",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.mfrac,{children:[(0,n.jsx)(i.mn,{children:"1"}),(0,n.jsx)(i.mi,{children:"e"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\frac{1}{e}"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"1.1901em",verticalAlign:"-0.345em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mopen nulldelimiter"}),(0,n.jsx)(i.span,{className:"mfrac",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsxs)(i.span,{className:"vlist",style:{height:"0.8451em"},children:[(0,n.jsxs)(i.span,{style:{top:"-2.655em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:(0,n.jsx)(i.span,{className:"mord mathnormal mtight",children:"e"})})})]}),(0,n.jsxs)(i.span,{style:{top:"-3.23em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(i.span,{className:"frac-line",style:{borderBottomWidth:"0.04em"}})]}),(0,n.jsxs)(i.span,{style:{top:"-3.394em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"1"})})})]})]}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.345em"},children:(0,n.jsx)(i.span,{})})})]})}),(0,n.jsx)(i.span,{className:"mclose nulldelimiter"})]})]})})]}),") della sua ampiezza iniziale a causa di processi di decoerenza da defasamento. In un ",(0,n.jsxs)(i.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/characterization/t2hahn.html",children:["esperimento Hahn Echo ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"2"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]})]}),", possiamo stimare il tasso di questo decadimento."]}),"\n",(0,n.jsx)(i.h4,{id:"state-preparation-and-measurement-spam-error-characterization",children:"Caratterizzazione dell'errore di preparazione dello stato e misurazione (SPAM)"}),"\n",(0,n.jsxs)(i.p,{children:["In un ",(0,n.jsx)(i.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/measurement/readout_mitigation.html",children:"esperimento di caratterizzazione dell'errore SPAM"})," i qubit vengono preparati in un certo stato (",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsxs)(i.mrow,{children:[(0,n.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,n.jsx)(i.mn,{children:"0"}),(0,n.jsx)(i.mo,{stretchy:"false",children:"\u27e9"})]}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\vert 0 \\rangle"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(i.span,{className:"mord",children:"\u22230"}),(0,n.jsx)(i.span,{className:"mclose",children:"\u27e9"})]})})]})," o ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsxs)(i.mrow,{children:[(0,n.jsx)(i.mi,{mathvariant:"normal",children:"\u2223"}),(0,n.jsx)(i.mn,{children:"1"}),(0,n.jsx)(i.mo,{stretchy:"false",children:"\u27e9"})]}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\vert 1 \\rangle"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(i.span,{className:"mord",children:"\u22231"}),(0,n.jsx)(i.span,{className:"mclose",children:"\u27e9"})]})})]}),") e misurati. La probabilit\xe0 di misurare uno stato diverso da quello preparato fornisce quindi la probabilit\xe0 dell'errore."]}),"\n",(0,n.jsx)(i.h4,{id:"single-qubit-and-two-qubit-randomized-benchmarking",children:"Randomized benchmarking a singolo qubit e a due qubit"}),"\n",(0,n.jsxs)(i.p,{children:["Il ",(0,n.jsx)(i.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/verification/randomized_benchmarking.html",children:"randomized benchmarking (RB)"})," \xe8 un protocollo popolare per caratterizzare il tasso di errore dei processori quantistici. Un esperimento RB consiste nella generazione di circuiti Clifford casuali sui qubit dati in modo tale che l'unitario calcolato dai circuiti sia l'identit\xe0. Dopo aver eseguito i circuiti, vengono contati il numero di misurazioni che risultano in un errore (cio\xe8, un output diverso dallo stato fondamentale), e da questi dati si possono dedurre stime degli errori per il dispositivo quantistico, calcolando l'Error Per Clifford."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"# Create T1 experiments on all qubit in parallel\nt1_exp = ParallelExperiment(\n    [\n        T1(\n            physical_qubits=[qubit],\n            delays=[1e-6, 20e-6, 40e-6, 80e-6, 200e-6, 400e-6],\n        )\n        for qubit in qubits\n    ],\n    backend,\n    analysis=None,\n)\n\n# Create T2-Hahn experiments on all qubit in parallel\nt2_exp = ParallelExperiment(\n    [\n        T2Hahn(\n            physical_qubits=[qubit],\n            delays=[1e-6, 20e-6, 40e-6, 80e-6, 200e-6, 400e-6],\n        )\n        for qubit in qubits\n    ],\n    backend,\n    analysis=None,\n)\n\n# Create readout experiments on all qubit in parallel\nreadout_exp = LocalReadoutError(qubits)\n\n# Create single-qubit RB experiments on all qubit in parallel\nsingleq_rb_exp = ParallelExperiment(\n    [\n        StandardRB(\n            physical_qubits=[qubit], lengths=[10, 100, 500], num_samples=10\n        )\n        for qubit in qubits\n    ],\n    backend,\n    analysis=None,\n)\n\n# Create two-qubit RB experiments on the three layers of disjoint edges of the heavy-hex\ntwoq_rb_exp_batched = BatchExperiment(\n    [\n        ParallelExperiment(\n            [\n                StandardRB(\n                    physical_qubits=pair,\n                    lengths=[10, 50, 100],\n                    num_samples=10,\n                )\n                for pair in layer\n            ],\n            backend,\n            analysis=None,\n        )\n        for layer in layered_coupling_map\n    ],\n    backend,\n    flatten_results=True,\n    analysis=None,\n)\n"})}),"\n",(0,n.jsx)(i.h3,{id:"qpu-properties-over-time",children:"Propriet\xe0 della QPU nel tempo"}),"\n",(0,n.jsx)(i.p,{children:"Osservando le propriet\xe0 riportate della QPU nel tempo (considereremo una singola settimana qui sotto), vediamo come queste possano fluttuare su una scala di un singolo giorno. Piccole fluttuazioni possono verificarsi anche nell'arco di una giornata. In questo scenario, le propriet\xe0 riportate (aggiornate una volta al giorno) non cattureranno accuratamente lo stato attuale della QPU. Inoltre, se un job viene traspilato localmente (utilizzando le propriet\xe0 riportate correnti) e inviato ma eseguito solo in un momento successivo (minuti o giorni), potrebbe correre il rischio di aver utilizzato propriet\xe0 obsolete per la selezione dei qubit nella fase di traspilazione. Questo evidenzia l'importanza di avere informazioni aggiornate sulla QPU al momento dell'esecuzione. Prima di tutto, recuperiamo le propriet\xe0 su un determinato intervallo di tempo."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'instruction_2q_name = "cz"  # set the name of the default 2q of the device\nerrors_list = []\nfor day_idx in range(10, 17):\n    calibrations_time = datetime(\n        year=2025, month=8, day=day_idx, hour=0, minute=0, second=0\n    )\n    targer_hist = backend.target_history(datetime=calibrations_time)\n\n    t1_dict, t2_dict = {}, {}\n    for qubit in range(targer_hist.num_qubits):\n        t1_dict[qubit] = targer_hist.qubit_properties[qubit].t1\n        t2_dict[qubit] = targer_hist.qubit_properties[qubit].t2\n\n    errors_dict = {\n        "1q": targer_hist["sx"],\n        "2q": targer_hist[f"{instruction_2q_name}"],\n        "spam": targer_hist["measure"],\n        "t1": t1_dict,\n        "t2": t2_dict,\n    }\n\n    errors_list.append(errors_dict)\n'})}),"\n",(0,n.jsx)(i.p,{children:"Quindi, tracciamo i valori"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'fig, axs = plt.subplots(5, 1, figsize=(10, 20), sharex=False)\n\n# Plot for T1 values\nfor qubit in range(targer_hist.num_qubits):\n    t1s = []\n    for errors_dict in errors_list:\n        t1_dict = errors_dict["t1"]\n        try:\n            t1s.append(t1_dict[qubit] / 1e-6)\n        except:\n            print(f"missing t1 data for qubit {qubit}")\n\n    axs[0].plot(t1s)\n\naxs[0].set_title("T1")\naxs[0].set_ylabel(r"Time ($\\mu s$)")\naxs[0].set_xlabel("Days")\n\n# Plot for T2 values\nfor qubit in range(targer_hist.num_qubits):\n    t2s = []\n    for errors_dict in errors_list:\n        t2_dict = errors_dict["t2"]\n        try:\n            t2s.append(t2_dict[qubit] / 1e-6)\n        except:\n            print(f"missing t2 data for qubit {qubit}")\n\n    axs[1].plot(t2s)\n\naxs[1].set_title("T2")\naxs[1].set_ylabel(r"Time ($\\mu s$)")\naxs[1].set_xlabel("Days")\n\n# Plot SPAM values\nfor qubit in range(targer_hist.num_qubits):\n    spams = []\n    for errors_dict in errors_list:\n        spam_dict = errors_dict["spam"]\n        spams.append(spam_dict[tuple([qubit])].error)\n\n    axs[2].plot(spams)\n\naxs[2].set_title("SPAM Errors")\naxs[2].set_ylabel("Error Rate")\naxs[2].set_xlabel("Days")\n\n# Plot 1Q Gate Errors\nfor qubit in range(targer_hist.num_qubits):\n    oneq_gates = []\n    for errors_dict in errors_list:\n        oneq_gate_dict = errors_dict["1q"]\n        oneq_gates.append(oneq_gate_dict[tuple([qubit])].error)\n\n    axs[3].plot(oneq_gates)\n\naxs[3].set_title("1Q Gate Errors")\naxs[3].set_ylabel("Error Rate")\naxs[3].set_xlabel("Days")\n\n# Plot 2Q Gate Errors\nfor pair in one_dir_coupling_map:\n    twoq_gates = []\n    for errors_dict in errors_list:\n        twoq_gate_dict = errors_dict["2q"]\n        twoq_gates.append(twoq_gate_dict[pair].error)\n\n    axs[4].plot(twoq_gates)\n\naxs[4].set_title("2Q Gate Errors")\naxs[4].set_ylabel("Error Rate")\naxs[4].set_xlabel("Days")\n\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n'})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Output of the previous code cell",src:s(70995).A+"",width:"863",height:"1625"})}),"\n",(0,n.jsx)(i.p,{children:"Potete vedere che nell'arco di diversi giorni alcune delle propriet\xe0 dei qubit possono cambiare considerevolmente. Questo evidenzia l'importanza di avere informazioni aggiornate sullo stato della QPU, per poter selezionare i qubit con le migliori prestazioni per un esperimento."}),"\n",(0,n.jsx)(i.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Step 2: Ottimizzare il problema per l'esecuzione su hardware quantistico"}),"\n",(0,n.jsx)(i.p,{children:"In questo tutorial non viene effettuata alcuna ottimizzazione dei circuiti o degli operatori."}),"\n",(0,n.jsx)(i.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Step 3: Eseguire utilizzando le primitive Qiskit"}),"\n",(0,n.jsx)(i.h3,{id:"execute-a-quantum-circuit-with-default-qubit-selection",children:"Eseguire un circuito quantistico con la selezione predefinita dei qubit"}),"\n",(0,n.jsxs)(i.p,{children:["Come risultato di riferimento per le prestazioni, eseguiremo un circuito quantistico su una QPU utilizzando i qubit predefiniti, che sono i qubit selezionati con le propriet\xe0 di backend richieste. Useremo ",(0,n.jsx)(i.code,{children:"optimization_level = 3"}),". Questa impostazione include l'ottimizzazione di transpilazione pi\xf9 avanzata e utilizza le propriet\xe0 del target (come gli errori delle operazioni) per selezionare i qubit con le migliori prestazioni per l'esecuzione."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'pm = generate_preset_pass_manager(target=backend.target, optimization_level=3)\nisa_circuits = pm.run(circuits)\ninitial_qubits = [\n    [\n        idx\n        for idx, qb in circuit.layout.initial_layout.get_physical_bits().items()\n        if qb._register.name != "ancilla"\n    ]\n    for circuit in isa_circuits\n]\n'})}),"\n",(0,n.jsx)(i.h3,{id:"execute-a-quantum-circuit-with-real-time-qubit-selection",children:"Eseguire un circuito quantistico con selezione dei qubit in tempo reale"}),"\n",(0,n.jsxs)(i.p,{children:["In questa sezione, investigheremo l'importanza di avere informazioni aggiornate sulle propriet\xe0 dei qubit della QPU per ottenere risultati ottimali. In primo luogo, eseguiremo una suite completa di esperimenti di caratterizzazione della QPU (",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"1"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]}),", ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"2"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]}),", SPAM, RB a singolo qubit e RB a due qubit), che potremo quindi utilizzare per aggiornare le propriet\xe0 del backend. Questo permette al pass manager di selezionare i qubit per l'esecuzione basandosi su informazioni fresche riguardo alla QPU, migliorando possibilmente le prestazioni di esecuzione. In secondo luogo, eseguiamo il circuito della coppia di Bell e confrontiamo la fedelt\xe0 ottenuta dopo aver selezionato i qubit con le propriet\xe0 QPU aggiornate rispetto alla fedelt\xe0 che abbiamo ottenuto prima quando utilizziamo le propriet\xe0 predefinite riportate per la selezione dei qubit."]}),"\n",(0,n.jsx)(a,{type:"caution",children:(0,n.jsxs)(i.p,{children:["Notate che alcuni degli esperimenti di caratterizzazione potrebbero fallire quando la routine di fitting non riesce ad adattare una curva ai dati misurati. Se vedete avvisi provenienti da questi esperimenti, ispezionateli per capire quale caratterizzazione \xe8 fallita su quali qubit, e provate ad aggiustare i parametri dell'esperimento (come i tempi per ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"1"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]}),", ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"T"}),(0,n.jsx)(i.mn,{children:"2"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]})]})})]}),", o il numero di lunghezze degli esperimenti RB)."]})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'# Prepare characterization experiments\nbatches = [t1_exp, t2_exp, readout_exp, singleq_rb_exp, twoq_rb_exp_batched]\nbatches_exp = BatchExperiment(batches, backend)  # , analysis=None)\nrun_options = {"shots": 1e3, "dynamic": False}\n\nwith Session(backend=backend) as session:\n    sampler = SamplerV2(mode=session)\n\n    # Run characterization experiments\n    batches_exp_data = batches_exp.run(\n        sampler=sampler, **run_options\n    ).block_for_results()\n\n    EPG_sx_result_list = batches_exp_data.analysis_results("EPG_sx")\n    EPG_sx_result_q_indices = [\n        result.device_components.index for result in EPG_sx_result_list\n    ]\n    EPG_x_result_list = batches_exp_data.analysis_results("EPG_x")\n    EPG_x_result_q_indices = [\n        result.device_components.index for result in EPG_x_result_list\n    ]\n    T1_result_list = batches_exp_data.analysis_results("T1")\n    T1_result_q_indices = [\n        result.device_components.index for result in T1_result_list\n    ]\n\n    T2_result_list = batches_exp_data.analysis_results("T2")\n    T2_result_q_indices = [\n        result.device_components.index for result in T2_result_list\n    ]\n\n    Readout_result_list = batches_exp_data.analysis_results(\n        "Local Readout Mitigator"\n    )\n\n    EPG_2q_result_list = batches_exp_data.analysis_results(\n        f"EPG_{instruction_2q_name}"\n    )\n\n    # Update target properties\n    target = copy.deepcopy(backend.target)\n    for i in range(target.num_qubits - 1):\n        qarg = (i,)\n\n        if qarg in EPG_sx_result_q_indices:\n            target.update_instruction_properties(\n                instruction="sx",\n                qargs=qarg,\n                properties=InstructionProperties(\n                    error=EPG_sx_result_list[i].value.nominal_value\n                ),\n            )\n        if qarg in EPG_x_result_q_indices:\n            target.update_instruction_properties(\n                instruction="x",\n                qargs=qarg,\n                properties=InstructionProperties(\n                    error=EPG_x_result_list[i].value.nominal_value\n                ),\n            )\n\n        err_mat = Readout_result_list.value.assignment_matrix(i)\n        readout_assignment_error = (\n            err_mat[0, 1] + err_mat[1, 0]\n        ) / 2  # average readout error\n        target.update_instruction_properties(\n            instruction="measure",\n            qargs=qarg,\n            properties=InstructionProperties(error=readout_assignment_error),\n        )\n\n        if qarg in T1_result_q_indices:\n            target.qubit_properties[i].t1 = T1_result_list[\n                i\n            ].value.nominal_value\n        if qarg in T2_result_q_indices:\n            target.qubit_properties[i].t2 = T2_result_list[\n                i\n            ].value.nominal_value\n\n    for pair_idx, pair in enumerate(one_dir_coupling_map):\n        qarg = tuple(pair)\n        try:\n            target.update_instruction_properties(\n                instruction=instruction_2q_name,\n                qargs=qarg,\n                properties=InstructionProperties(\n                    error=EPG_2q_result_list[pair_idx].value.nominal_value\n                ),\n            )\n        except:\n            target.update_instruction_properties(\n                instruction=instruction_2q_name,\n                qargs=qarg[::-1],\n                properties=InstructionProperties(\n                    error=EPG_2q_result_list[pair_idx].value.nominal_value\n                ),\n            )\n\n    # transpile circuits to updated target\n    pm = generate_preset_pass_manager(target=target, optimization_level=3)\n    isa_circuit_updated = pm.run(circuits)\n    updated_qubits = [\n        [\n            idx\n            for idx, qb in circuit.layout.initial_layout.get_physical_bits().items()\n            if qb._register.name != "ancilla"\n        ]\n        for circuit in isa_circuit_updated\n    ]\n\n    n_trials = 3  # run multiple trials to see variations\n\n    # interleave circuits\n    interleaved_circuits = []\n    for original_circuit, updated_circuit in zip(\n        isa_circuits, isa_circuit_updated\n    ):\n        interleaved_circuits.append(original_circuit)\n        interleaved_circuits.append(updated_circuit)\n\n    # Run circuits\n    # Set simple error suppression/mitigation options\n    sampler.options.dynamical_decoupling.enable = True\n    sampler.options.dynamical_decoupling.sequence_type = "XY4"\n\n    job_interleaved = sampler.run(interleaved_circuits * n_trials)\n'})}),"\n",(0,n.jsx)(i.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Step 4: Post-processare e restituire il risultato nel formato classico desiderato"}),"\n",(0,n.jsx)(i.p,{children:"Infine, confrontiamo la fedelt\xe0 dello stato di Bell ottenuto nelle due diverse configurazioni:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"original"}),", cio\xe8 con i qubit predefiniti scelti dal transpiler basandosi sulle propriet\xe0 riportate del backend."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"updated"}),", cio\xe8 con i qubit scelti basandosi sulle propriet\xe0 aggiornate del backend dopo che gli esperimenti di caratterizzazione sono stati eseguiti."]}),"\n"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"results = job_interleaved.result()\nall_fidelity_list, all_fidelity_updated_list = [], []\nfor exp_idx in range(n_trials):\n    fidelity_list, fidelity_updated_list = [], []\n\n    for idx, num_qubits in enumerate(num_qubits_list):\n        pub_result_original = results[\n            2 * exp_idx * len(num_qubits_list) + 2 * idx\n        ]\n        pub_result_updated = results[\n            2 * exp_idx * len(num_qubits_list) + 2 * idx + 1\n        ]\n\n        fid = hellinger_fidelity(\n            ideal_dist, pub_result_original.data.c.get_counts()\n        )\n        fidelity_list.append(fid)\n\n        fid_up = hellinger_fidelity(\n            ideal_dist, pub_result_updated.data.c.get_counts()\n        )\n        fidelity_updated_list.append(fid_up)\n    all_fidelity_list.append(fidelity_list)\n    all_fidelity_updated_list.append(fidelity_updated_list)\n"})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'plt.figure(figsize=(8, 6))\nplt.errorbar(\n    num_qubits_list,\n    np.mean(all_fidelity_list, axis=0),\n    yerr=np.std(all_fidelity_list, axis=0),\n    fmt="o-.",\n    label="original",\n    color="b",\n)\n# plt.plot(num_qubits_list, fidelity_list, \'-.\')\nplt.errorbar(\n    num_qubits_list,\n    np.mean(all_fidelity_updated_list, axis=0),\n    yerr=np.std(all_fidelity_updated_list, axis=0),\n    fmt="o-.",\n    label="updated",\n    color="r",\n)\n# plt.plot(num_qubits_list, fidelity_updated_list, \'-.\')\nplt.xlabel("Chain length")\nplt.xticks(num_qubits_list)\nplt.ylabel("Fidelity")\nplt.title("Bell pair fidelity at the edge of N-qubits chain")\nplt.legend()\nplt.grid(\n    alpha=0.2,\n    linestyle="-.",\n)\nplt.show()\n'})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Output of the previous code cell",src:s(24071).A+"",width:"700",height:"547"})}),"\n",(0,n.jsx)(i.p,{children:"Non tutte le esecuzioni mostreranno un miglioramento nelle prestazioni dovuto alla caratterizzazione in tempo reale - e con l'aumentare della lunghezza della catena, e quindi con meno libert\xe0 di scegliere qubit fisici, l'importanza delle informazioni aggiornate del dispositivo diventa meno sostanziale. Tuttavia, \xe8 buona pratica raccogliere dati freschi sulle propriet\xe0 del dispositivo per comprenderne le prestazioni. Occasionalmente, sistemi a due livelli transitori possono influenzare le prestazioni di alcuni qubit. I dati in tempo reale possono informarci quando tali eventi si verificano e aiutarci ad evitare fallimenti sperimentali in tali circostanze."}),"\n",(0,n.jsx)(a,{type:"note",title:"Call to action",children:(0,n.jsx)(i.p,{children:"Provate ad applicare questo metodo alle vostre esecuzioni e determinate quanto beneficio ottenete! Potete anche provare a vedere quanti miglioramenti ottenete da backend diversi."})}),"\n",(0,n.jsx)(i.h2,{id:"tutorial-survey",children:"Tutorial survey"}),"\n",(0,n.jsx)(i.p,{children:"Vi preghiamo di compilare questo breve sondaggio per fornire feedback su questo tutorial. Le vostre opinioni ci aiuteranno a migliorare la nostra offerta di contenuti e l'esperienza utente."})]})}function m(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}function p(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},76086(e,i,s){s.d(i,{A:()=>a});const a=s.p+"assets/images/64c25da9-a728-4ae4-a377-3078a1dc618d-0-f9deaef9341eae4bbdeb3f4719165675.avif"},70917(e,i,s){s.d(i,{A:()=>a});const a=s.p+"assets/images/64c25da9-a728-4ae4-a377-3078a1dc618d-1-f9deaef9341eae4bbdeb3f4719165675.avif"},24071(e,i,s){s.d(i,{A:()=>a});const a=s.p+"assets/images/656ec97a-3fd9-4635-9a98-1c5589761689-0-29407ac0caee92ba8022fb2629479197.avif"},70995(e,i,s){s.d(i,{A:()=>a});const a=s.p+"assets/images/e0ba509d-e0e0-438b-aedf-5e01919c7d4f-0-ece591eb9ccc6bc0d20ca8dfd5508559.avif"},28453(e,i,s){s.d(i,{R:()=>r,x:()=>l});var a=s(96540);const n={},t=a.createContext(n);function r(e){const i=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(t.Provider,{value:i},e.children)}}}]);