"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[5953],{19234(e,t,i){i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"guides/common-parameters","title":"Commonly used parameters for transpilation","description":"Overview of commonly used parameters controlling quantum circuit transpilation in Qiskit.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/guides/common-parameters.mdx","sourceDirName":"guides","slug":"/guides/common-parameters","permalink":"/guides/common-parameters","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/common-parameters.mdx","tags":[],"version":"current","frontMatter":{"title":"Commonly used parameters for transpilation","sidebar_label":"Commonly used parameters for transpilation","description":"Overview of commonly used parameters controlling quantum circuit transpilation in Qiskit.","notebook_path":"docs/guides/common-parameters.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Set transpiler optimization level","permalink":"/guides/set-optimization"},"next":{"title":"Represent quantum computers","permalink":"/guides/represent-quantum-computers"}}');var s=i(74848),a=i(28453);const r={title:"Commonly used parameters for transpilation",sidebar_label:"Commonly used parameters for transpilation",description:"Overview of commonly used parameters controlling quantum circuit transpilation in Qiskit.",notebook_path:"docs/guides/common-parameters.ipynb"},o=void 0,l={},c=[{value:"Approximation degree",id:"approximation-degree",level:2},{value:"Random number generator seed",id:"random-number-generator-seed",level:2},{value:"Initial layout",id:"initial-layout",level:2},{value:"Transpiler stage and plugin options",id:"transpiler-stage-and-plugin-options",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const t={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components},{Admonition:n,Details:r,OpenInLabBanner:o}=t;return n||p("Admonition",!0),r||p("Details",!0),o||p("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(t.admonition,{title:"Non ancora tradotto",type:"note",children:(0,s.jsx)(t.p,{children:"Questa pagina non \xe8 stata ancora tradotta. Stai visualizzando la versione originale in inglese."})}),"\n",(0,s.jsx)(o,{notebookPath:"docs/guides/common-parameters.ipynb"}),"\n","\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)("b",{children:"Package versions"})}),(0,s.jsx)(t.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\n"})})]}),"\n",(0,s.jsxs)(t.p,{children:["This page describes some of the more commonly used parameters for local transpilation. These parameters are configured using arguments to ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.generate_preset_pass_manager#qiskit.transpiler.generate_preset_pass_manager",children:(0,s.jsx)(t.code,{children:"generate_preset_pass_manager"})})," or ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/compiler#qiskit.compiler.transpile",children:(0,s.jsx)(t.code,{children:"transpile"})}),"."]}),"\n",(0,s.jsx)("span",{id:"approx-degree"}),"\n",(0,s.jsx)(t.h2,{id:"approximation-degree",children:"Approximation degree"}),"\n",(0,s.jsx)(t.p,{children:"You can use the approximation degree to specify how closely you want the resultant circuit to match the desired (input) circuit.  This is a float in the range (0.0 - 1.0), where 0.0 is maximum approximation and 1.0 (default) is no approximation. Smaller values trade output accuracy for ease of execution (that is, fewer gates).  The default value is 1.0."}),"\n",(0,s.jsx)(t.p,{children:"In two-qubit unitary synthesis (used in initial stages of all levels and for optimization stage with optimization level 3), this value specifies the target fidelity of the output decomposition. That is, how much error is introduced when a matrix representation of a circuit is converted to discrete gates. If the approximation degree is a lower value (more approximation), the output circuit from synthesis will differ more from the input matrix, but will also likely have fewer gates (because any arbitrary two-qubit operation can be decomposed perfectly with at most three CX gates) and is easier to run."}),"\n",(0,s.jsxs)(t.p,{children:["When the approximation degree is less than 1.0, circuits with one or two CX gates might be synthesized, leading to less error from the hardware, but more from the approximation. Since CX is the most expensive gate in terms of error, it might be beneficial to decrease the number of them at the cost of fidelity in synthesis (this technique was used to increase quantum volume on IBM\xae devices: ",(0,s.jsx)(t.a,{href:"https://arxiv.org/abs/1811.12926",children:"Validating quantum computers using randomized model circuits"}),")."]}),"\n",(0,s.jsxs)(t.p,{children:["As an example, we generate a random two-qubit ",(0,s.jsx)(t.code,{children:"UnitaryGate"})," which will be synthesized in the initial stage. Setting the ",(0,s.jsx)(t.code,{children:"approximation_degree"})," less than 1.0 might generate an approximate circuit. We must also specify the ",(0,s.jsx)(t.code,{children:"basis_gates"})," to let the synthesis method know which gates it can use for the approximate synthesis."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Added by doQumentation \u2014 required packages for this notebook\n%pip install -q qiskit qiskit-ibm-runtime\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from qiskit import QuantumCircuit, QuantumRegister\nfrom qiskit.circuit.library import UnitaryGate\nfrom qiskit.quantum_info import random_unitary\nfrom qiskit.transpiler import generate_preset_pass_manager\n\nUU = random_unitary(4, seed=12345)\nrand_U = UnitaryGate(UU)\n\nqubits = QuantumRegister(2, name="q")\nqc = QuantumCircuit(qubits)\nqc.append(rand_U, qubits)\npass_manager = generate_preset_pass_manager(\n    optimization_level=1,\n    approximation_degree=0.85,\n    basis_gates=["sx", "rz", "cx"],\n)\napprox_qc = pass_manager.run(qc)\nprint(approx_qc.count_ops()["cx"])\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"2\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This yields an output of ",(0,s.jsx)(t.code,{children:"2"})," because the approximation requires fewer CX gates."]}),"\n",(0,s.jsx)("span",{id:"seed"}),"\n",(0,s.jsx)(t.h2,{id:"random-number-generator-seed",children:"Random number generator seed"}),"\n",(0,s.jsxs)(t.p,{children:["Some parts of the transpiler are stochastic, so repeated transpilation runs may return different results. To obtain a reproducible result, you can set the seed for the pseudorandom number generator using the ",(0,s.jsx)(t.code,{children:"seed_transpiler"})," argument. Repeated runs using the same seed will return the same results."]}),"\n",(0,s.jsx)(t.p,{children:"Example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'pass_manager = generate_preset_pass_manager(\n    optimization_level=1, seed_transpiler=11, basis_gates=["sx", "rz", "cx"]\n)\noptimized_1 = pass_manager.run(qc)\noptimized_1.draw("mpl")\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:i(59279).A+"",width:"1097",height:"178"})}),"\n",(0,s.jsx)("span",{id:"init-layout"}),"\n",(0,s.jsx)(t.h2,{id:"initial-layout",children:"Initial layout"}),"\n",(0,s.jsxs)(t.p,{children:["Before transpilation, the qubits contained in your circuit are virtual qubits that don't necessarily correspond to physical qubits on the target backend. You can specify the initial mapping of virtual qubits to physical qubits using the ",(0,s.jsx)(t.code,{children:"initial_layout"})," argument. Note that the final qubit layout may differ from the initial layout because the transpiler may permute qubits using swap gates or other means."]}),"\n",(0,s.jsxs)(t.p,{children:["In the example below, we construct an initial layout for the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/fake-provider-fake-sherbrooke#fakesherbrooke",children:(0,s.jsx)(t.code,{children:"FakeSherbrooke"})})," mock backend by creating a ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.Layout",children:(0,s.jsx)(t.code,{children:"Layout"})})," object. Our layout maps the first qubit of our circuit to qubit 5 of Sherbrooke, and it maps the second qubit of our circuit to qubit 6 of Sherbrooke. Note that physical qubits are always represented by integers."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from qiskit_ibm_runtime.fake_provider import FakeSherbrooke\nfrom qiskit.transpiler import Layout\n\nbackend = FakeSherbrooke()\n\na, b = qubits\ninitial_layout = Layout({a: 5, b: 6})\n\npass_manager = generate_preset_pass_manager(\n    optimization_level=1, backend=backend, initial_layout=initial_layout\n)\ntranspiled_circ = pass_manager.run(qc)\n\ntranspiled_circ.draw("mpl", idle_wires=False)\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:i(25462).A+"",width:"1383",height:"178"})}),"\n",(0,s.jsxs)(t.p,{children:["In addition to specifying a Layout object, you can also pass a list of integers, where the ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"i"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6595em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"i"})]})})]}),"-th element of the list contains the physical qubit that the ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"i"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6595em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"i"})]})})]}),"-th qubit should be mapped to. For example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'initial_layout = [5, 6]\n\npass_manager = generate_preset_pass_manager(\n    optimization_level=1, backend=backend, initial_layout=initial_layout\n)\ntranspiled_circ = pass_manager.run(qc)\n\ntranspiled_circ.draw("mpl", idle_wires=False)\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:i(58447).A+"",width:"1383",height:"178"})}),"\n",(0,s.jsxs)(t.p,{children:["You can use the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.visualization.plot_error_map",children:(0,s.jsx)(t.code,{children:"plot_error_map"})})," function to generate a diagram of the device graph with error information and with the physical qubits labeled. You can also view similar diagrams on the ",(0,s.jsx)(t.a,{href:"https://quantum.cloud.ibm.com/computers",children:"Compute resources"})," page."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"from qiskit.visualization import plot_error_map\n\nplot_error_map(backend, figsize=(30, 24))\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:i(94144).A+"",width:"2321",height:"1862"})}),"\n",(0,s.jsx)("span",{id:"xx-method"}),"\n",(0,s.jsx)(t.h2,{id:"transpiler-stage-and-plugin-options",children:"Transpiler stage and plugin options"}),"\n",(0,s.jsxs)(t.p,{children:["These options are suffixed with ",(0,s.jsx)(t.code,{children:"_method"}),". They influence how the transpiler works and are used to try and get better, different, or specific output from the transpiler."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"init_method"})," (str) - The plugin to use for the initialization stage."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"layout_method"})," (str) - The layout selection pass (",(0,s.jsx)(t.code,{children:"trivial"}),", ",(0,s.jsx)(t.code,{children:"dense"}),", ",(0,s.jsx)(t.code,{children:"sabre"}),"). This can also be the external plugin name to use for the layout stage."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"optimization_method"})," (str) - The plugin to use for the optimization stage."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"routing_method"})," (str) - Name of routing pass (",(0,s.jsx)(t.code,{children:"basic"}),", ",(0,s.jsx)(t.code,{children:"lookahead"}),", ",(0,s.jsx)(t.code,{children:"default"}),", ",(0,s.jsx)(t.code,{children:"sabre"}),", ",(0,s.jsx)(t.code,{children:"none"}),"). This can also be the external plugin name to use for the routing stage."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"scheduling_method"})," (str) - Name of scheduling pass. This can also be the external plugin name to use for the scheduling stage."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"as_soon_as_possible"}),": Schedule instructions greedily: as early as possible on a qubit resource (alias: ",(0,s.jsx)(t.code,{children:"asap"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"as_late_as_possible"}),": Schedule instructions late.  That is, keep qubits in the ground state when possible (alias: ",(0,s.jsx)(t.code,{children:"alap"}),")."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"translation_method"})," (str) - Name of translation pass (",(0,s.jsx)(t.code,{children:"unroller"}),", ",(0,s.jsx)(t.code,{children:"translator"}),", ",(0,s.jsx)(t.code,{children:"synthesis"}),"). This can also be the external plugin name to use for the translation stage."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"unitary_synthesis_method"})," (str) - The name of the unitary synthesis method to use. By default ",(0,s.jsx)(t.code,{children:"default"})," is used."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n,{type:"note",children:(0,s.jsxs)(t.p,{children:["To see a list of all installed plugins for a given stage, run ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/transpiler_plugins",children:(0,s.jsx)(t.code,{children:'list_stage_plugins("stage_name")'})}),". For example, if you want to see a list of all installed plugins for the routing stage, run ",(0,s.jsx)(t.code,{children:"list_stage_plugins(routing)"}),"."]})}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(n,{type:"tip",title:"Recommendation",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Review the ",(0,s.jsx)(t.a,{href:"defaults-and-configuration-options",children:"Default options and configuration settings"})," topic."]}),"\n",(0,s.jsxs)(t.li,{children:["Learn how to ",(0,s.jsx)(t.a,{href:"set-optimization",children:"Set the optimization level."})]}),"\n",(0,s.jsxs)(t.li,{children:["Try the ",(0,s.jsx)(t.a,{href:"/guides/circuit-transpilation-settings",children:"Compare transpiler settings"})," guide."]}),"\n",(0,s.jsxs)(t.li,{children:["Review the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/transpiler",children:"transpiler API documentation."})]}),"\n"]})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function p(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},94144(e,t,i){i.d(t,{A:()=>n});const n=i.p+"assets/images/8df57c6a-1ff4-4d58-9b7e-4378452c3025-0-3e05e7a411e38a59758676042441b767.svg"},58447(e,t,i){i.d(t,{A:()=>n});const n=i.p+"assets/images/a7800d8a-7354-48e4-a55f-f902ae28c875-0-f2dc5fbca93d233e2b57fc58063b1a40.svg"},59279(e,t,i){i.d(t,{A:()=>n});const n=i.p+"assets/images/dbc652e8-53a4-47a9-a66e-d9c1e5ef07c9-0-742e4db1a3ab48f795ad141d1b6594a2.svg"},25462(e,t,i){i.d(t,{A:()=>n});const n=i.p+"assets/images/e18c034c-eb26-4d9d-81d7-37e0eafa17c7-0-d76b17d173cbed17ec458a1bdd5bb886.svg"},28453(e,t,i){i.d(t,{R:()=>r,x:()=>o});var n=i(96540);const s={},a=n.createContext(s);function r(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);