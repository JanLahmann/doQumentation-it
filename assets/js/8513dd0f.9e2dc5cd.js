"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[7840],{20168(e,i,n){n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"tutorials/spin-chain-vqe","title":"Stima dell\'energia dello stato fondamentale della catena di Heisenberg con VQE","description":"Costruisci, implementa ed esegui un pattern Qiskit per simulare una catena di Heisenberg e stimare l\'energia del suo stato fondamentale.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/spin-chain-vqe.mdx","sourceDirName":"tutorials","slug":"/tutorials/spin-chain-vqe","permalink":"/tutorials/spin-chain-vqe","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/spin-chain-vqe.mdx","tags":[],"version":"current","frontMatter":{"title":"Stima dell\'energia dello stato fondamentale della catena di Heisenberg con VQE","sidebar_label":"Stima dell\'energia dello stato fondamentale della catena di Heisenberg con VQE","description":"Costruisci, implementa ed esegui un pattern Qiskit per simulare una catena di Heisenberg e stimare l\'energia del suo stato fondamentale.","notebook_path":"docs/tutorials/spin-chain-vqe.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Transizione di fase di Nishimori","permalink":"/tutorials/nishimori-phase-transition"},"next":{"title":"Addestramento del kernel quantistico","permalink":"/tutorials/quantum-kernel-training"}}');var a=n(74848),s=n(28453);const r={title:"Stima dell'energia dello stato fondamentale della catena di Heisenberg con VQE",sidebar_label:"Stima dell'energia dello stato fondamentale della catena di Heisenberg con VQE",description:"Costruisci, implementa ed esegui un pattern Qiskit per simulare una catena di Heisenberg e stimare l'energia del suo stato fondamentale.",notebook_path:"docs/tutorials/spin-chain-vqe.ipynb"},l="Stima dell'energia dello stato fondamentale della catena di Heisenberg con VQE {#ground-state-energy-estimation-of-the-heisenberg-chain-with-vqe}",o={},c=[{value:"Contesto",id:"background",level:2},{value:"Requisiti",id:"requirements",level:2},{value:"Configurazione",id:"setup",level:2},{value:"Passaggio 1: Mappare input classici a un problema quantistico",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Passaggio 2: Ottimizzare il problema per l&#39;esecuzione su hardware quantistico",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Passaggio 3: Eseguire utilizzando le primitive Qiskit",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Passaggio 4: Post-elaborare e restituire il risultato nel formato classico desiderato",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Implementare il pattern Qiskit nel cloud",id:"deploy-the-qiskit-pattern-to-the-cloud",level:2},{value:"Eseguire il pattern Qiskit come servizio gestito",id:"run-the-qiskit-pattern-as-a-managed-service",level:3},{value:"Sondaggio sul tutorial",id:"tutorial-survey",level:2}];function u(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components},{OpenInLabBanner:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("OpenInLabBanner",!0),(0,a.jsxs)(a.Fragment,{children:["\n",(0,a.jsx)(t,{notebookPath:"docs/tutorials/spin-chain-vqe.ipynb"}),"\n",(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"ground-state-energy-estimation-of-the-heisenberg-chain-with-vqe",children:"Stima dell'energia dello stato fondamentale della catena di Heisenberg con VQE"})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.em,{children:"Stima dell'utilizzo: Due minuti su un processore Eagle r3 (NOTA: Questa \xe8 solo una stima. Il tuo tempo di esecuzione potrebbe variare.)"})}),"\n",(0,a.jsx)(i.h2,{id:"background",children:"Contesto"}),"\n",(0,a.jsxs)(i.p,{children:["Questo tutorial mostra come costruire, implementare ed eseguire un ",(0,a.jsx)(i.code,{children:"pattern Qiskit"})," per simulare una catena di Heisenberg e stimare l'energia del suo stato fondamentale. Per ulteriori informazioni sui ",(0,a.jsx)(i.code,{children:"pattern Qiskit"})," e su come ",(0,a.jsx)(i.code,{children:"Qiskit Serverless"})," pu\xf2 essere utilizzato per implementarli nel cloud per un'esecuzione gestita, visitate la nostra ",(0,a.jsx)(i.a,{href:"/guides/serverless",children:"pagina della documentazione su IBM Quantum\xae Platform"}),"."]}),"\n",(0,a.jsx)(i.h2,{id:"requirements",children:"Requisiti"}),"\n",(0,a.jsx)(i.p,{children:"Prima di iniziare questo tutorial, assicurati di avere installato quanto segue:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["Qiskit SDK v1.2 o successivo, con supporto per la ",(0,a.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualizzazione"})]}),"\n",(0,a.jsxs)(i.li,{children:["Qiskit Runtime v0.28 o successivo (",(0,a.jsx)(i.code,{children:"pip install qiskit-ibm-runtime"}),")"]}),"\n",(0,a.jsx)(i.li,{children:"Qiskit Serverless (pip install qiskit_serverless)"}),"\n",(0,a.jsx)(i.li,{children:"IBM Catalog (pip install qiskit-ibm-catalog)"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"setup",children:"Configurazione"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.optimize import minimize\nfrom typing import Sequence\n\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.primitives.base import BaseEstimatorV2\nfrom qiskit.circuit.library import XGate\nfrom qiskit.circuit.library import efficient_su2\nfrom qiskit.transpiler import PassManager\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit.transpiler.passes.scheduling import (\n    ALAPScheduleAnalysis,\n    PadDynamicalDecoupling,\n)\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import Session, Estimator\n\nfrom qiskit_ibm_catalog import QiskitServerless, QiskitFunction\n"})}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'def visualize_results(results):\n    plt.plot(results["cost_history"], lw=2)\n    plt.xlabel("Iteration")\n    plt.ylabel("Energy")\n    plt.show()\n\ndef build_callback(\n    ansatz: QuantumCircuit,\n    hamiltonian: SparsePauliOp,\n    estimator: BaseEstimatorV2,\n    callback_dict: dict,\n):\n    def callback(current_vector):\n        # Keep track of the number of iterations\n        callback_dict["iters"] += 1\n        # Set the prev_vector to the latest one\n        callback_dict["prev_vector"] = current_vector\n        # Compute the value of the cost function at the current vector\n        current_cost = (\n            estimator.run([(ansatz, hamiltonian, [current_vector])])\n            .result()[0]\n            .data.evs[0]\n        )\n        callback_dict["cost_history"].append(current_cost)\n        # Print to screen on single line\n        print(\n            "Iters. done: {} [Current cost: {}]".format(\n                callback_dict["iters"], current_cost\n            ),\n            end="\\r",\n            flush=True,\n        )\n\n    return callback\n'})}),"\n",(0,a.jsx)(i.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Passaggio 1: Mappare input classici a un problema quantistico"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Input: Numero di spin"}),"\n",(0,a.jsx)(i.li,{children:"Output: Ansatz e Hamiltoniana che modellano la catena di Heisenberg"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Costruite un ansatz e un'Hamiltoniana che modellano una catena di Heisenberg a 10 spin. Per prima cosa, importiamo alcuni pacchetti generici e creiamo un paio di funzioni di supporto."}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'num_spins = 10\nansatz = efficient_su2(num_qubits=num_spins, reps=3)\n\n# Remember to insert your token in the QiskitRuntimeService constructor\nservice = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, min_num_qubits=num_spins, simulator=False\n)\n\ncoupling = backend.target.build_coupling_map()\nreduced_coupling = coupling.reduce(list(range(num_spins)))\n\nedge_list = reduced_coupling.graph.edge_list()\nham_list = []\n\nfor edge in edge_list:\n    ham_list.append(("ZZ", edge, 0.5))\n    ham_list.append(("YY", edge, 0.5))\n    ham_list.append(("XX", edge, 0.5))\n\nfor qubit in reduced_coupling.physical_qubits:\n    ham_list.append(("Z", [qubit], np.random.random() * 2 - 1))\n\nhamiltonian = SparsePauliOp.from_sparse_list(ham_list, num_qubits=num_spins)\n\nansatz.draw("mpl", style="iqp")\n'})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"Output of the previous code cell",src:n(32313).A+"",width:"1464",height:"689"})}),"\n",(0,a.jsx)(i.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Passaggio 2: Ottimizzare il problema per l'esecuzione su hardware quantistico"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Input: Circuito astratto, osservabile"}),"\n",(0,a.jsx)(i.li,{children:"Output: Circuito target e osservabile, ottimizzati per la QPU selezionata"}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["Utilizza la funzione ",(0,a.jsx)(i.code,{children:"generate_preset_pass_manager"})," di Qiskit per generare automaticamente una routine di ottimizzazione per il nostro circuito rispetto alla QPU selezionata. Scegliamo ",(0,a.jsx)(i.code,{children:"optimization_level=3"}),", che fornisce il livello pi\xf9 alto di ottimizzazione dei pass manager preimpostati. Includiamo anche i passaggi di scheduling ",(0,a.jsx)(i.code,{children:"ALAPScheduleAnalysis"})," e ",(0,a.jsx)(i.code,{children:"PadDynamicalDecoupling"})," per sopprimere gli errori di decoerenza."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'target = backend.target\npm = generate_preset_pass_manager(optimization_level=3, backend=backend)\npm.scheduling = PassManager(\n    [\n        ALAPScheduleAnalysis(durations=target.durations()),\n        PadDynamicalDecoupling(\n            durations=target.durations(),\n            dd_sequence=[XGate(), XGate()],\n            pulse_alignment=target.pulse_alignment,\n        ),\n    ]\n)\nansatz_ibm = pm.run(ansatz)\nobservable_ibm = hamiltonian.apply_layout(ansatz_ibm.layout)\nansatz_ibm.draw("mpl", scale=0.6, style="iqp", fold=-1, idle_wires=False)\n'})}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.img,{alt:"Output of the previous code cell",src:n(43858).A+"",width:"2859",height:"434"})}),"\n",(0,a.jsx)(i.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Passaggio 3: Eseguire utilizzando le primitive Qiskit"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Input: Circuito target e osservabile"}),"\n",(0,a.jsx)(i.li,{children:"Output: Risultati dell'ottimizzazione"}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["Minimizza l'energia stimata dello stato fondamentale del sistema ottimizzando i parametri del circuito. Utilizza la primitiva ",(0,a.jsx)(i.code,{children:"Estimator"})," di Qiskit Runtime per valutare la funzione di costo durante l'ottimizzazione."]}),"\n",(0,a.jsxs)(i.p,{children:["Per questa demo, eseguiremo su una QPU utilizzando le primitive ",(0,a.jsx)(i.code,{children:"qiskit-ibm-runtime"}),". Per eseguire con le primitive basate su statevector di ",(0,a.jsx)(i.code,{children:"qiskit"}),", sostituite il blocco di codice che utilizza le primitive Qiskit IBM Runtime con il blocco commentato."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'# SciPy minimizer routine\ndef cost_func(\n    params: Sequence,\n    ansatz: QuantumCircuit,\n    hamiltonian: SparsePauliOp,\n    estimator: BaseEstimatorV2,\n) -> float:\n    """Ground state energy evaluation."""\n    return (\n        estimator.run([(ansatz, hamiltonian, [params])])\n        .result()[0]\n        .data.evs[0]\n    )\n\nnum_params = ansatz_ibm.num_parameters\nparams = 2 * np.pi * np.random.random(num_params)\n\ncallback_dict = {\n    "prev_vector": None,\n    "iters": 0,\n    "cost_history": [],\n}\n\n# Evaluate the problem on a QPU by using Qiskit IBM Runtime\nwith Session(backend=backend) as session:\n    estimator = Estimator()\n    callback = build_callback(\n        ansatz_ibm, observable_ibm, estimator, callback_dict\n    )\n    res = minimize(\n        cost_func,\n        x0=params,\n        args=(ansatz_ibm, observable_ibm, estimator),\n        callback=callback,\n        method="cobyla",\n        options={"maxiter": 100},\n    )\n\nvisualize_results(callback_dict)\n'})}),"\n",(0,a.jsx)(i.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Passaggio 4: Post-elaborare e restituire il risultato nel formato classico desiderato"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Input: Stime dell'energia dello stato fondamentale durante l'ottimizzazione"}),"\n",(0,a.jsx)(i.li,{children:"Output: Energia stimata dello stato fondamentale"}),"\n"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:"print(f'Estimated ground state energy: {res[\"fun\"]}')\n"})}),"\n",(0,a.jsx)(i.h2,{id:"deploy-the-qiskit-pattern-to-the-cloud",children:"Implementare il pattern Qiskit nel cloud"}),"\n",(0,a.jsxs)(i.p,{children:["Per fare ci\xf2, spostate il codice sorgente sopra in un file, ",(0,a.jsx)(i.code,{children:"./source/heisenberg.py"}),", racchiudete il codice in uno script che accetta input e restituisce la soluzione finale, e infine caricatelo su un cluster remoto utilizzando la classe ",(0,a.jsx)(i.code,{children:"QiskitFunction"})," di ",(0,a.jsx)(i.code,{children:"qiskit-ibm-catalog"}),". Per indicazioni su come specificare le dipendenze esterne, passare argomenti di input e altro ancora, consultate le ",(0,a.jsx)(i.a,{href:"/guides/serverless",children:"guide di Qiskit Serverless"}),"."]}),"\n",(0,a.jsx)(i.p,{children:"L'input del Pattern \xe8 il numero di spin nella catena. L'output \xe8 una stima dell'energia dello stato fondamentale del sistema."}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'# Authenticate to the remote cluster and submit the pattern for remote execution\nserverless = QiskitServerless()\nheisenberg_function = QiskitFunction(\n    title="ibm_heisenberg",\n    entrypoint="heisenberg.py",\n    working_dir="./source/",\n)\nserverless.upload(heisenberg_function)\n'})}),"\n",(0,a.jsx)(i.h3,{id:"run-the-qiskit-pattern-as-a-managed-service",children:"Eseguire il pattern Qiskit come servizio gestito"}),"\n",(0,a.jsxs)(i.p,{children:["Una volta caricato il pattern nel cloud, possiamo eseguirlo facilmente utilizzando il client ",(0,a.jsx)(i.code,{children:"QiskitServerless"}),"."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-python",children:'# Run the pattern on the remote cluster\n\nibm_heisenberg = serverless.load("ibm_heisenberg")\njob = serverless.run(ibm_heisenberg)\nsolution = job.result()\n\nprint(solution)\nprint(job.logs())\n'})}),"\n",(0,a.jsx)(i.h2,{id:"tutorial-survey",children:"Sondaggio sul tutorial"}),"\n",(0,a.jsx)(i.p,{children:"Ti preghiamo di rispondere a questo breve sondaggio per fornire feedback su questo tutorial. Il tuo feedback ci aiuter\xe0 a migliorare i nostri contenuti e l'esperienza utente."}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.a,{href:"https://your.feedback.ibm.com/jfe/form/SV_bfuBwfNeeFBxnim",children:"Link to survey"})})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},32313(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/7e8d2f10-f1d6-4ec2-bac9-9db23499c9e1-0-f9954cab2138e804a339c51fb0fbc32c.avif"},43858(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/a0a5f1c8-5c31-4d9f-ae81-37bd67271d44-0-7ea21c8c521df2de5e333683e145c990.avif"},28453(e,i,n){n.d(i,{R:()=>r,x:()=>l});var t=n(96540);const a={},s=t.createContext(a);function r(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);