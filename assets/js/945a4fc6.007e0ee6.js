"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[3947],{44277(e,i,n){n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"tutorials/global-data-quantum-optimizer","title":"Ottimizzatore di Portfolio Quantistico - Una Funzione Qiskit di Global Data Quantum","description":"Risolvete un problema di ottimizzazione dinamica su scala industriale utilizzando l\'Ottimizzatore di Portfolio Quantistico di Global Data Quantum.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/global-data-quantum-optimizer.mdx","sourceDirName":"tutorials","slug":"/tutorials/global-data-quantum-optimizer","permalink":"/tutorials/global-data-quantum-optimizer","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/global-data-quantum-optimizer.mdx","tags":[],"version":"current","frontMatter":{"title":"Ottimizzatore di Portfolio Quantistico - Una Funzione Qiskit di Global Data Quantum","sidebar_label":"Ottimizzatore di Portfolio Quantistico - Una Funzione Qiskit di Global Data Quantum","description":"Risolvete un problema di ottimizzazione dinamica su scala industriale utilizzando l\'Ottimizzatore di Portfolio Quantistico di Global Data Quantum.","notebook_path":"docs/tutorials/global-data-quantum-optimizer.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Simulazione dell\'Hamiltoniana di Ising con impulsi usando circuiti dinamici","permalink":"/tutorials/dc-hex-ising"},"next":{"title":"Mitigazione degli errori con la funzione IBM Circuit","permalink":"/tutorials/error-mitigation-with-qiskit-functions"}}');var t=n(74848),s=n(28453);const o={title:"Ottimizzatore di Portfolio Quantistico - Una Funzione Qiskit di Global Data Quantum",sidebar_label:"Ottimizzatore di Portfolio Quantistico - Una Funzione Qiskit di Global Data Quantum",description:"Risolvete un problema di ottimizzazione dinamica su scala industriale utilizzando l'Ottimizzatore di Portfolio Quantistico di Global Data Quantum.",notebook_path:"docs/tutorials/global-data-quantum-optimizer.ipynb"},l="Eseguite l'ottimizzazione dinamica di portfolio con l'Ottimizzatore di Portfolio di Global Data Quantum {#perform-dynamic-portfolio-optimization-with-global-data-quantums-portfolio-optimizer}",r={},d=[{value:"Contesto",id:"background",level:2},{value:"Requisiti",id:"requirements",level:2},{value:"Configurazione",id:"setup",level:2},{value:"Passo 1: Leggere il portfolio di input",id:"step-1-read-the-input-portfolio",level:2},{value:"Passo 2: Definire gli input del problema",id:"step-2-define-the-problem-inputs",level:2},{value:"Step 3: Analizzare i risultati dell&#39;ottimizzazione",id:"step-3-analyze-the-optimization-results",level:2},{value:"Riferimenti",id:"references",level:2},{value:"Sondaggio sul tutorial",id:"tutorial-survey",level:2}];function c(e){const i={a:"a",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mfrac:"mfrac",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components},{Admonition:a,OpenInLabBanner:o}=i;return a||p("Admonition",!0),o||p("OpenInLabBanner",!0),(0,t.jsxs)(t.Fragment,{children:["\n",(0,t.jsx)(o,{notebookPath:"docs/tutorials/global-data-quantum-optimizer.ipynb"}),"\n","\n",(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"perform-dynamic-portfolio-optimization-with-global-data-quantums-portfolio-optimizer",children:"Eseguite l'ottimizzazione dinamica di portfolio con l'Ottimizzatore di Portfolio di Global Data Quantum"})}),"\n",(0,t.jsx)(a,{type:"note",title:"Note",children:(0,t.jsx)(i.p,{children:"Le Funzioni Qiskit sono una funzionalit\xe0 sperimentale disponibile solo per gli utenti dei piani IBM Quantum\xae Premium Plan, Flex Plan e On-Prem (tramite l'API della IBM Quantum Platform). Sono in stato di rilascio in anteprima e soggette a modifiche."})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.em,{children:"Stima di utilizzo: Circa 55 minuti su un processore Heron r2. (NOTA: Questa \xe8 solo una stima. Il tempo di esecuzione effettivo pu\xf2 variare.)"})}),"\n",(0,t.jsx)(i.h2,{id:"background",children:"Contesto"}),"\n",(0,t.jsx)(i.p,{children:"Il problema dell'ottimizzazione dinamica di portfolio mira a trovare la strategia di investimento ottimale su pi\xf9 periodi temporali per massimizzare il rendimento atteso del portfolio e minimizzare i rischi, spesso sotto determinati vincoli come budget, costi di transazione o avversione al rischio. A differenza dell'ottimizzazione di portfolio standard, che considera un singolo momento per ribilanciare il portfolio, la versione dinamica tiene conto della natura evolutiva degli asset e adatta gli investimenti in base ai cambiamenti nelle performance degli asset nel tempo."}),"\n",(0,t.jsx)(i.p,{children:"Questo tutorial dimostra come eseguire l'ottimizzazione dinamica di portfolio utilizzando la Funzione Qiskit Ottimizzatore di Portfolio Quantistico. Nello specifico, illustriamo come utilizzare questa funzione applicativa per risolvere un problema di allocazione degli investimenti su pi\xf9 passi temporali."}),"\n",(0,t.jsxs)(i.p,{children:["L'approccio prevede la formulazione dell'ottimizzazione di portfolio come un problema multi-obiettivo di Ottimizzazione Binaria Quadratica Non Vincolata (QUBO). Specificamente, formuliamo la funzione QUBO ",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsx)(i.mrow,{children:(0,t.jsx)(i.mi,{children:"O"})}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"O"})]})})}),(0,t.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"})]})})]})," per ottimizzare simultaneamente quattro diversi obiettivi:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Massimizzare la funzione di rendimento ",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsx)(i.mrow,{children:(0,t.jsx)(i.mi,{children:"F"})}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"F"})]})})}),(0,t.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"})]})})]})]}),"\n",(0,t.jsxs)(i.li,{children:["Minimizzare il rischio dell'investimento ",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsx)(i.mrow,{children:(0,t.jsx)(i.mi,{children:"R"})}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"R"})]})})}),(0,t.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.00773em"},children:"R"})]})})]})]}),"\n",(0,t.jsxs)(i.li,{children:["Minimizzare i costi di transazione ",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsx)(i.mrow,{children:(0,t.jsx)(i.mi,{children:"C"})}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"C"})]})})}),(0,t.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"})]})})]})]}),"\n",(0,t.jsxs)(i.li,{children:["Rispettare le restrizioni sugli investimenti, formulate in un termine aggiuntivo per minimizzare ",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsx)(i.mrow,{children:(0,t.jsx)(i.mi,{children:"P"})}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"P"})]})})}),(0,t.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"P"})]})})]}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["In sintesi, per affrontare questi obiettivi formuliamo la funzione QUBO come\n",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsxs)(i.mrow,{children:[(0,t.jsx)(i.mi,{children:"O"}),(0,t.jsx)(i.mo,{children:"="}),(0,t.jsx)(i.mo,{children:"\u2212"}),(0,t.jsx)(i.mi,{children:"F"}),(0,t.jsx)(i.mo,{children:"+"}),(0,t.jsxs)(i.mfrac,{children:[(0,t.jsx)(i.mi,{children:"\u03b3"}),(0,t.jsx)(i.mn,{children:"2"})]}),(0,t.jsx)(i.mi,{children:"R"}),(0,t.jsx)(i.mo,{children:"+"}),(0,t.jsx)(i.mi,{children:"C"}),(0,t.jsx)(i.mo,{children:"+"}),(0,t.jsx)(i.mi,{children:"\u03c1"}),(0,t.jsx)(i.mi,{children:"P"}),(0,t.jsx)(i.mo,{separator:"true",children:","})]}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"O = -F + \\frac{\\gamma}{2} R + C + \\rho P,"})]})})}),(0,t.jsxs)(i.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(i.span,{className:"mrel",children:"="}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.7667em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(i.span,{className:"mord",children:"\u2212"}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(i.span,{className:"mbin",children:"+"}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"1.0925em",verticalAlign:"-0.345em"}}),(0,t.jsxs)(i.span,{className:"mord",children:[(0,t.jsx)(i.span,{className:"mopen nulldelimiter"}),(0,t.jsx)(i.span,{className:"mfrac",children:(0,t.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,t.jsxs)(i.span,{className:"vlist-r",children:[(0,t.jsxs)(i.span,{className:"vlist",style:{height:"0.7475em"},children:[(0,t.jsxs)(i.span,{style:{top:"-2.655em"},children:[(0,t.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(i.span,{className:"mord mtight",children:(0,t.jsx)(i.span,{className:"mord mtight",children:"2"})})})]}),(0,t.jsxs)(i.span,{style:{top:"-3.23em"},children:[(0,t.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsx)(i.span,{className:"frac-line",style:{borderBottomWidth:"0.04em"}})]}),(0,t.jsxs)(i.span,{style:{top:"-3.4461em"},children:[(0,t.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,t.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(i.span,{className:"mord mtight",children:(0,t.jsx)(i.span,{className:"mord mathnormal mtight",style:{marginRight:"0.05556em"},children:"\u03b3"})})})]})]}),(0,t.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,t.jsx)(i.span,{className:"vlist-r",children:(0,t.jsx)(i.span,{className:"vlist",style:{height:"0.345em"},children:(0,t.jsx)(i.span,{})})})]})}),(0,t.jsx)(i.span,{className:"mclose nulldelimiter"})]}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.00773em"},children:"R"}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(i.span,{className:"mbin",children:"+"}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.7667em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(i.span,{className:"mbin",children:"+"}),(0,t.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"\u03c1P"}),(0,t.jsx)(i.span,{className:"mpunct",children:","})]})]})]}),"\ndove ",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsx)(i.mrow,{children:(0,t.jsx)(i.mi,{children:"\u03b3"})}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\gamma"})]})})}),(0,t.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.05556em"},children:"\u03b3"})]})})]})," \xe8 il coefficiente di avversione al rischio e ",(0,t.jsxs)(i.span,{className:"katex",children:[(0,t.jsx)(i.span,{className:"katex-mathml",children:(0,t.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(i.semantics,{children:[(0,t.jsx)(i.mrow,{children:(0,t.jsx)(i.mi,{children:"\u03c1"})}),(0,t.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\rho"})]})})}),(0,t.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(i.span,{className:"base",children:[(0,t.jsx)(i.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,t.jsx)(i.span,{className:"mord mathnormal",children:"\u03c1"})]})})]})," \xe8 il coefficiente di rafforzamento delle restrizioni (moltiplicatore di Lagrange). La formulazione esplicita pu\xf2 essere trovata nell'Eq. (15) del nostro manoscritto ",(0,t.jsx)(i.a,{href:"#references",children:"[1]"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["Risolviamo utilizzando un metodo ibrido quantistico-classico basato sul Variational Quantum Eigensolver (VQE). In questa configurazione, il circuito quantistico stima la funzione di costo, mentre l'ottimizzazione classica viene eseguita utilizzando l'algoritmo Differential Evolution, consentendo una navigazione efficiente del panorama delle soluzioni. Il numero di qubit richiesti dipende da tre fattori principali: il numero di asset ",(0,t.jsx)(i.code,{children:"na"}),", il numero di periodi temporali ",(0,t.jsx)(i.code,{children:"nt"})," e la risoluzione in bit utilizzata per rappresentare l'investimento ",(0,t.jsx)(i.code,{children:"nq"}),". Specificamente, il numero minimo di qubit nel nostro problema \xe8 ",(0,t.jsx)(i.code,{children:"na*nt*nq"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Per questo tutorial, ci concentriamo sull'ottimizzazione di un portfolio regionale basato sull'indice spagnolo IBEX 35. Specificamente, utilizziamo un portfolio di sette asset come indicato nella tabella seguente:"}),"\n",(0,t.jsx)(i.table,{children:(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:(0,t.jsx)(i.strong,{children:"IBEX 35 Portfolio"})}),(0,t.jsx)(i.th,{children:"ACS.MC"}),(0,t.jsx)(i.th,{children:"ITX.MC"}),(0,t.jsx)(i.th,{children:"FER.MC"}),(0,t.jsx)(i.th,{children:"ELE.MC"}),(0,t.jsx)(i.th,{children:"SCYR.MC"}),(0,t.jsx)(i.th,{children:"AENA.MC"}),(0,t.jsx)(i.th,{children:"AMS.MC"})]})})}),"\n",(0,t.jsx)(i.p,{children:"Ribilanciamo il nostro portfolio in quattro passi temporali, ciascuno separato da un intervallo di 30 giorni a partire dal 1\xb0 novembre 2022. Ogni variabile di investimento \xe8 codificata utilizzando due bit. Questo si traduce in un problema che richiede 56 qubit per essere risolto."}),"\n",(0,t.jsx)(i.p,{children:"Utilizziamo l'ansatz Optimized Real Amplitudes, un adattamento personalizzato ed efficiente dal punto di vista hardware dell'ansatz standard Real Amplitudes, specificamente progettato per migliorare le prestazioni per questo tipo di problema di ottimizzazione finanziaria."}),"\n",(0,t.jsxs)(i.p,{children:["L'esecuzione quantistica viene eseguita sul backend ",(0,t.jsx)(i.code,{children:"ibm_torino"}),". Per una spiegazione dettagliata della formulazione del problema, della metodologia e della valutazione delle prestazioni, fate riferimento al manoscritto pubblicato ",(0,t.jsx)(i.a,{href:"#references",children:"[1]"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"requirements",children:"Requisiti"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"!pip install qiskit-ibm-catalog\n!pip install pandas\n!pip install matplotlib\n!pip install yfinance\n"})}),"\n",(0,t.jsx)(i.h2,{id:"setup",children:"Configurazione"}),"\n",(0,t.jsx)(i.p,{children:"Per utilizzare l'Ottimizzatore di Portfolio Quantistico, selezionate la funzione tramite il Catalogo delle Funzioni Qiskit. Avete bisogno di un account IBM Quantum Premium Plan o Flex Plan con una licenza di Global Data Quantum per eseguire questa funzione."}),"\n",(0,t.jsxs)(i.p,{children:["Per prima cosa, autenticatevi con la vostra ",(0,t.jsx)(i.a,{href:"https://quantum.cloud.ibm.com",children:"chiave API."})," Quindi, caricate la funzione desiderata dal Catalogo delle Funzioni Qiskit. Qui, state accedendo alla funzione ",(0,t.jsx)(i.code,{children:"quantum_portfolio_optimizer"})," dal catalogo utilizzando la classe ",(0,t.jsx)(i.code,{children:"QiskitFunctionsCatalog"}),". Questa funzione ci consente di utilizzare il risolutore predefinito di Ottimizzazione di Portfolio Quantistico."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'from qiskit_ibm_catalog import QiskitFunctionsCatalog\n\ncatalog = QiskitFunctionsCatalog(\n    channel="ibm_quantum_platform",\n    instance="INSTANCE_CRN",\n    token="YOUR_API_KEY",  # Use the 44-character API_KEY you created and saved from the IBM Quantum Platform Home dashboard\n)\n\n# Access function\ndpo_solver = catalog.load("global-data-quantum/quantum-portfolio-optimizer")\n'})}),"\n",(0,t.jsx)(i.h2,{id:"step-1-read-the-input-portfolio",children:"Passo 1: Leggere il portfolio di input"}),"\n",(0,t.jsxs)(i.p,{children:["In questo passo, carichiamo i dati storici per i sette asset selezionati dall'indice IBEX 35, specificamente dal ",(0,t.jsx)(i.strong,{children:"1\xb0 novembre 2022"})," al ",(0,t.jsx)(i.strong,{children:"1\xb0 aprile 2023"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Recuperiamo i dati utilizzando l'API di Yahoo Finance, concentrandoci sui prezzi di chiusura. I dati vengono poi elaborati per garantire che tutti gli asset abbiano lo stesso numero di giorni con dati disponibili. Eventuali dati mancanti (giorni non di negoziazione) vengono gestiti in modo appropriato, assicurando che tutti gli asset siano allineati sulle stesse date."}),"\n",(0,t.jsx)(i.p,{children:"I dati sono strutturati in un DataFrame con formattazione coerente per tutti gli asset."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'import yfinance as yf\nimport pandas as pd\n\n# List of IBEX 35 symbols\nsymbols = [\n    "ACS.MC",\n    "ITX.MC",\n    "FER.MC",\n    "ELE.MC",\n    "SCYR.MC",\n    "AENA.MC",\n    "AMS.MC",\n]\n\nstart_date = "2022-11-01"\nend_date = "2023-4-01"\n\nseries_list = []\nsymbol_names = [symbol.replace(".", "_") for symbol in symbols]\n\n# Create a full date index including weekends\nfull_index = pd.date_range(start=start_date, end=end_date, freq="D")\n\nfor symbol, name in zip(symbols, symbol_names):\n    print(f"Downloading data for {symbol}...")\n    data = yf.download(symbol, start=start_date, end=end_date)["Close"]\n    data.name = name\n\n    # Reindex to include weekends\n    data = data.reindex(full_index)\n\n    # Fill missing values (for example, weekends or holidays) by forward/backward fill\n    data.ffill(inplace=True)\n    data.bfill(inplace=True)\n\n    series_list.append(data)\n\n# Combine all series into a single DataFrame\ndf = pd.concat(series_list, axis=1)\n\n# Convert index to string for consistency\ndf.index = df.index.astype(str)\n\n# Convert DataFrame to dictionary\nassets = df.to_dict()\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"[*********************100%***********************]  1 of 1 completed\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Downloading data for ACS.MC...\nDownloading data for ITX.MC...\nDownloading data for FER.MC...\nDownloading data for ELE.MC...\nDownloading data for SCYR.MC...\nDownloading data for AENA.MC...\nDownloading data for AMS.MC...\n"})}),"\n",(0,t.jsx)(i.h2,{id:"step-2-define-the-problem-inputs",children:"Passo 2: Definire gli input del problema"}),"\n",(0,t.jsxs)(i.p,{children:["I parametri necessari per definire il problema QUBO sono configurati nel dizionario ",(0,t.jsx)(i.code,{children:"qubo_settings"}),". Definiamo il numero di passi temporali (",(0,t.jsx)(i.code,{children:"nt"}),"), il numero di bit per la specificazione dell'investimento (",(0,t.jsx)(i.code,{children:"nq"}),") e la finestra temporale per ogni passo (",(0,t.jsx)(i.code,{children:"dt"}),"). Inoltre, impostiamo l'investimento massimo per asset, il coefficiente di avversione al rischio, la commissione di transazione e il coefficiente di restrizione (consultate ",(0,t.jsx)(i.a,{href:"https://arxiv.org/pdf/2412.19150",children:"il nostro articolo"})," per i dettagli sulla formulazione del problema). Queste impostazioni ci consentono di adattare il problema QUBO allo scenario di investimento specifico."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'qubo_settings = {\n    "nt": 4,\n    "nq": 2,\n    "dt": 30,\n    "max_investment": 5,  # maximum investment per asset is 2**nq/max_investment = 80%\n    "risk_aversion": 1000.0,\n    "transaction_fee": 0.01,\n    "restriction_coeff": 1.0,\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Il dizionario ",(0,t.jsx)(i.code,{children:"optimizer_settings"})," configura il processo di ottimizzazione, includendo parametri come ",(0,t.jsx)(i.code,{children:"num_generations"})," per il numero di iterazioni e ",(0,t.jsx)(i.code,{children:"population_size"})," per il numero di soluzioni candidate per generazione. Altre impostazioni controllano aspetti come il tasso di ricombinazione, i job paralleli, la dimensione del batch e il range di mutazione. Inoltre, le impostazioni primitive, come ",(0,t.jsx)(i.code,{children:"estimator_shots"}),", ",(0,t.jsx)(i.code,{children:"estimator_precision"})," e ",(0,t.jsx)(i.code,{children:"sampler_shots"}),", definiscono le configurazioni dell'estimator quantistico e del sampler per il processo di ottimizzazione."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'optimizer_settings = {\n    "de_optimizer_settings": {\n        "num_generations": 20,\n        "population_size": 40,\n        "recombination": 0.4,\n        "max_parallel_jobs": 5,\n        "max_batchsize": 4,\n        "mutation_range": [0.0, 0.25],\n    },\n    "optimizer": "differential_evolution",\n    "primitive_settings": {\n        "estimator_shots": 25_000,\n        "estimator_precision": None,\n        "sampler_shots": 100_000,\n    },\n}\n'})}),"\n",(0,t.jsx)(a,{type:"note",children:(0,t.jsxs)(i.p,{children:["Il numero totale di circuiti dipende dai parametri di ",(0,t.jsx)(i.code,{children:"optimizer_settings"})," ed \xe8 calcolato come ",(0,t.jsx)(i.code,{children:"(num_generations + 1) * population_size"}),"."]})}),"\n",(0,t.jsxs)(i.p,{children:["Il dizionario ",(0,t.jsx)(i.code,{children:"ansatz_settings"})," configura l'ansatz del circuito quantistico. Il parametro ",(0,t.jsx)(i.code,{children:"ansatz"})," specifica l'uso dell'approccio ",(0,t.jsx)(i.code,{children:'"optimized_real_amplitudes"'}),", che \xe8 un ansatz efficiente dal punto di vista hardware progettato per problemi di ottimizzazione finanziaria. Inoltre, l'impostazione ",(0,t.jsx)(i.code,{children:"multiple_passmanager"})," \xe8 abilitata per consentire pi\xf9 pass manager (incluso il pass manager locale predefinito di Qiskit e il servizio transpiler basato su AI di Qiskit) durante il processo di ottimizzazione, migliorando le prestazioni complessive e l'efficienza dell'esecuzione del circuito."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'ansatz_settings = {\n    "ansatz": "optimized_real_amplitudes",\n    "multiple_passmanager": False,\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Infine, eseguiamo l'ottimizzazione lanciando la funzione ",(0,t.jsx)(i.code,{children:"dpo_solver.run()"}),", passando gli input preparati. Questi includono il dizionario dei dati degli asset (",(0,t.jsx)(i.code,{children:"assets"}),"), la configurazione QUBO (",(0,t.jsx)(i.code,{children:"qubo_settings"}),"), i parametri di ottimizzazione (",(0,t.jsx)(i.code,{children:"optimizer_settings"}),") e le impostazioni dell'ansatz del circuito quantistico (",(0,t.jsx)(i.code,{children:"ansatz_settings"}),"). Inoltre, specifichiamo i dettagli di esecuzione come il backend e se applicare il post-processing ai risultati. Questo avvia il processo di ottimizzazione dinamica di portfolio sul backend quantistico selezionato."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'dpo_job = dpo_solver.run(\n    assets=assets,\n    qubo_settings=qubo_settings,\n    optimizer_settings=optimizer_settings,\n    ansatz_settings=ansatz_settings,\n    backend_name="ibm_torino",\n    previous_session_id=[],\n    apply_postprocess=True,\n)\n'})}),"\n",(0,t.jsx)(i.h2,{id:"step-3-analyze-the-optimization-results",children:"Step 3: Analizzare i risultati dell'ottimizzazione"}),"\n",(0,t.jsx)(i.p,{children:"In questa sezione, estraiamo e visualizziamo la soluzione con il costo obiettivo pi\xf9 basso dai risultati dell'ottimizzazione. Insieme al costo obiettivo minimo, presentiamo anche le metriche chiave associate alla soluzione corrispondente, tra cui la deviazione delle restrizioni, il rapporto di Sharpe e il rendimento dell'investimento."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Get the results of the job\ndpo_result = dpo_job.result()\n\n# Show the solution strategy\ndpo_result["result"]\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"{'time_step_0': {'ACS.MC': 0.11764705882352941,\n  'ITX.MC': 0.20588235294117646,\n  'FER.MC': 0.38235294117647056,\n  'ELE.MC': 0.058823529411764705,\n  'SCYR.MC': 0.0,\n  'AENA.MC': 0.058823529411764705,\n  'AMS.MC': 0.17647058823529413},\n 'time_step_1': {'ACS.MC': 0.11428571428571428,\n  'ITX.MC': 0.14285714285714285,\n  'FER.MC': 0.2,\n  'ELE.MC': 0.02857142857142857,\n  'SCYR.MC': 0.42857142857142855,\n  'AENA.MC': 0.0,\n  'AMS.MC': 0.08571428571428572},\n 'time_step_2': {'ACS.MC': 0.0,\n  'ITX.MC': 0.09375,\n  'FER.MC': 0.3125,\n  'ELE.MC': 0.34375,\n  'SCYR.MC': 0.0,\n  'AENA.MC': 0.0,\n  'AMS.MC': 0.25},\n 'time_step_3': {'ACS.MC': 0.3939393939393939,\n  'ITX.MC': 0.09090909090909091,\n  'FER.MC': 0.12121212121212122,\n  'ELE.MC': 0.18181818181818182,\n  'SCYR.MC': 0.0,\n  'AENA.MC': 0.0,\n  'AMS.MC': 0.21212121212121213}}\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'import pandas as pd\n\n# Get results from the job\ndpo_result = dpo_job.result()\n\n# Convert metadata to a DataFrame, excluding \'session_id\'\ndf = pd.DataFrame(dpo_result["metadata"]["all_samples_metrics"])\n\n# Find the minimum objective cost\nmin_cost = df["objective_costs"].min()\nprint(f"Minimum Objective Cost Found: {min_cost:.2f}")\n\n# Extract the row with the lowest cost\nbest_row = df[df["objective_costs"] == min_cost].iloc[0]\n\n# Display the results associated with the best solution\nprint("Best Solution:")\nprint(f"  - Restriction Deviation: {best_row[\'rest_breaches\']}%")\nprint(f"  - Sharpe Ratio: {best_row[\'sharpe_ratios\']:.2f}")\nprint(f"  - Return: {best_row[\'returns\']:.2f}")\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Minimum Objective Cost Found: -3.67\nBest Solution:\n  - Restriction Deviation: 40.0%\n  - Sharpe Ratio: 14.54\n  - Return: 0.28\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Il codice seguente mostra come visualizzare e confrontare la distribuzione dei costi di un algoritmo di ottimizzazione con una distribuzione di campionamento casuale. Allo stesso modo, esploriamo il panorama della funzione obiettivo QUBO (che pu\xf2 essere caricata dall'output della funzione) valutandola con investimenti casuali. Tracciamo entrambe le distribuzioni normalizzate in ampiezza per un confronto pi\xf9 agevole di come il processo di ottimizzazione differisca dal campionamento casuale in termini di costo. Inoltre, il risultato ottenuto utilizzando DOCPlex \xe8 incluso come linea di riferimento verticale tratteggiata per fungere da benchmark classico. Utilizziamo la ",(0,t.jsx)(i.a,{href:"https://ibmdecisionoptimization.github.io/docplex-doc/",children:"versione gratuita di DOCPlex"})," \u2014 la libreria open-source IBM\xae per l'ottimizzazione matematica in Python \u2014 per risolvere lo stesso problema in modo classico."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'import matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\nimport matplotlib.patheffects as patheffects\n\ndef plot_normalized(dpo_x, dpo_y_normalized, random_x, random_y_normalized):\n    """\n    Plots normalized results for two sampling results.\n\n    Parameters:\n        dpo_x (array-like): X-values for the VQE Post-processed curve.\n        dpo_y_normalized (array-like): Y-values (normalized) for the VQE Post-processed curve.\n        random_x (array-like): X-values for the Noise (Random) curve.\n        random_y_normalized (array-like): Y-values (normalized) for the Noise (Random) curve.\n    """\n    plt.figure(figsize=(6, 3))\n    plt.tick_params(axis="both", which="major", labelsize=12)\n\n    # Define custom colors\n    colors = ["#4823E8", "#9AA4AD"]\n\n    # Plot DPO results\n    (line1,) = plt.plot(\n        dpo_x, dpo_y_normalized, label="VQE Postprocessed", color=colors[0]\n    )\n    line1.set_path_effects(\n        [patheffects.withStroke(linewidth=3, foreground="white")]\n    )\n\n    # Plot Random results\n    (line2,) = plt.plot(\n        random_x, random_y_normalized, label="Noise (Random)", color=colors[1]\n    )\n    line2.set_path_effects(\n        [patheffects.withStroke(linewidth=3, foreground="white")]\n    )\n\n    # Set X-axis ticks to increment by 5 units\n    plt.gca().xaxis.set_major_locator(MultipleLocator(5))\n\n    # Axis labels and legend\n    plt.xlabel("Objective cost", fontsize=14)\n    plt.ylabel("Normalized Counts", fontsize=14)\n\n    # Add DOCPLEX reference line\n    plt.axvline(\n        x=-4.11, color="black", linestyle="--", linewidth=1, label="DOCPlex"\n    )  # DOCPlex value\n    plt.ylim(bottom=0)\n\n    plt.legend()\n\n    # Adjust layout\n    plt.tight_layout()\n    plt.show()\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom collections import defaultdict\n\n# ================================\n# STEP 1: DPO COST DISTRIBUTION\n# ================================\n\n# Extract data from DPO results\ncounts_list = dpo_result["metadata"]["all_samples_metrics"][\n    "objective_costs"\n]  # List of how many times each solution occurred\ncost_list = dpo_result["metadata"]["all_samples_metrics"][\n    "counts"\n]  # List of corresponding objective function values (costs)\n\n# Round costs to one decimal and accumulate counts for each unique cost\ndpo_counter = defaultdict(int)\nfor cost, count in zip(cost_list, counts_list):\n    rounded_cost = round(cost, 1)\n    dpo_counter[rounded_cost] += count\n\n# Prepare data for plotting\ndpo_x = sorted(dpo_counter.keys())  # Sorted list of cost values\ndpo_y = [dpo_counter[c] for c in dpo_x]  # Corresponding counts\n\n# Normalize the counts to the range [0, 1] for better comparison\ndpo_min = min(dpo_y)\ndpo_max = max(dpo_y)\ndpo_y_normalized = [\n    (count - dpo_min) / (dpo_max - dpo_min) for count in dpo_y\n]\n\n# ================================\n# STEP 2: RANDOM COST DISTRIBUTION\n# ================================\n\n# Read the QUBO matrix\nqubo = np.array(dpo_result["metadata"]["qubo"])\n\nbitstring_length = qubo.shape[0]\nnum_random_samples = 100_000  # Number of random samples to generate\nrandom_cost_counter = defaultdict(int)\n\n# Generate random bitstrings and calculate their cost\nfor _ in range(num_random_samples):\n    x = np.random.randint(0, 2, size=bitstring_length)\n    cost = float(x @ qubo @ x.T)\n    rounded_cost = round(cost, 1)\n    random_cost_counter[rounded_cost] += 1\n\n# Prepare random data for plotting\nrandom_x = sorted(random_cost_counter.keys())\nrandom_y = [random_cost_counter[c] for c in random_x]\n\n# Normalize the random cost distribution\nrandom_min = min(random_y)\nrandom_max = max(random_y)\nrandom_y_normalized = [\n    (count - random_min) / (random_max - random_min) for count in random_y\n]\n\n# ================================\n# STEP 3: PLOTTING\n# ================================\n\nplot_normalized(dpo_x, dpo_y_normalized, random_x, random_y_normalized)\n'})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Output of the previous code cell",src:n(36628).A+"",width:"589",height:"290"})}),"\n",(0,t.jsx)(i.p,{children:"Il grafico mostra come l'ottimizzatore quantistico di portafoglio restituisca costantemente strategie di investimento ottimizzate."}),"\n",(0,t.jsx)(i.h2,{id:"references",children:"Riferimenti"}),"\n",(0,t.jsxs)(i.p,{children:["[1] ",(0,t.jsx)(i.a,{href:"https://arxiv.org/pdf/2412.19150",children:'Nodar, \xc1lvaro, Irene De Le\xf3n, Danel Arias, Ernesto Mamedaliev, Mar\xeda Esperanza Molina, Manuel Mart\xedn-Cordero, Senaida Hern\xe1ndez-Santana et al. "Scaling the Variational Quantum Eigensolver for Dynamic Portfolio Optimization." arXiv preprint arXiv:2412.19150 (2024).'})]}),"\n",(0,t.jsx)(i.h2,{id:"tutorial-survey",children:"Sondaggio sul tutorial"})]})}function m(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}function p(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},36628(e,i,n){n.d(i,{A:()=>a});const a="data:image/avif;base64,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"},28453(e,i,n){n.d(i,{R:()=>o,x:()=>l});var a=n(96540);const t={},s=a.createContext(t);function o(e){const i=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(s.Provider,{value:i},e.children)}}}]);