"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1711],{56609(e,i,s){s.r(i),s.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"tutorials/error-mitigation-with-qiskit-functions","title":"Mitigazione degli errori con la funzione IBM Circuit","description":"Seguite un esempio di costruzione ed esecuzione di un workflow utilizzando la funzione IBM Circuit.","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/tutorials/error-mitigation-with-qiskit-functions.mdx","sourceDirName":"tutorials","slug":"/tutorials/error-mitigation-with-qiskit-functions","permalink":"/tutorials/error-mitigation-with-qiskit-functions","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/error-mitigation-with-qiskit-functions.mdx","tags":[],"version":"current","frontMatter":{"title":"Mitigazione degli errori con la funzione IBM Circuit","sidebar_label":"Mitigazione degli errori con la funzione IBM Circuit","description":"Seguite un esempio di costruzione ed esecuzione di un workflow utilizzando la funzione IBM Circuit.","notebook_path":"docs/tutorials/error-mitigation-with-qiskit-functions.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Ottimizzatore di Portfolio Quantistico - Una Funzione Qiskit di Global Data Quantum","permalink":"/tutorials/global-data-quantum-optimizer"},"next":{"title":"Ottimizzazione binaria di ordine superiore con l\'Optimization Solver di Q-CTRL","permalink":"/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver"}}');var n=s(74848),t=s(28453);const r={title:"Mitigazione degli errori con la funzione IBM Circuit",sidebar_label:"Mitigazione degli errori con la funzione IBM Circuit",description:"Seguite un esempio di costruzione ed esecuzione di un workflow utilizzando la funzione IBM Circuit.",notebook_path:"docs/tutorials/error-mitigation-with-qiskit-functions.ipynb"},l=void 0,o={},c=[{value:"Contesto",id:"background",level:2},{value:"Requisiti",id:"requirements",level:2},{value:"Configurazione",id:"setup",level:2},{value:"Passo 1: Mappare gli input classici a un problema quantistico",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Costruire il circuito",id:"construct-the-circuit",level:4},{value:"Costruire l&#39;osservabile",id:"construct-the-observable",level:4},{value:"Passi 2 e 3: Ottimizzare il problema per l&#39;esecuzione su hardware quantistico ed eseguire con la funzione IBM Circuit",id:"steps-2-and-3-optimize-problem-for-quantum-hardware-execution-and-execute-with-the-ibm-circuit-function",level:2},{value:"Passo 4: Post-elaborare e restituire il risultato nel formato classico desiderato",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Calcolare la magnetizzazione globale",id:"compute-the-global-magnetization",level:4},{value:"Sondaggio sul tutorial",id:"tutorial-survey",level:2}];function m(e){const i={a:"a",annotation:"annotation",code:"code",em:"em",h2:"h2",h4:"h4",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mover:"mover",mrow:"mrow",msub:"msub",msubsup:"msubsup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,t.R)(),...e.components},{Admonition:a,OpenInLabBanner:r}=i;return a||u("Admonition",!0),r||u("OpenInLabBanner",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r,{notebookPath:"docs/tutorials/error-mitigation-with-qiskit-functions.ipynb"}),"\n",(0,n.jsx)(a,{type:"note",title:"Nota",children:(0,n.jsx)(i.p,{children:"Le Qiskit Functions sono una funzionalit\xe0 sperimentale disponibile solo per gli utenti di IBM Quantum\xae Premium Plan, Flex Plan e On-Prem (tramite API IBM Quantum Platform) Plan. Sono in stato di rilascio di anteprima e soggette a modifiche."})}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.em,{children:"Stima di utilizzo: 26 minuti su un processore Eagle (NOTA: Questa \xe8 solo una stima. Il tempo di esecuzione effettivo potrebbe variare.)"}),"\nQuesto tutorial illustra un esempio di costruzione ed esecuzione di un workflow utilizzando la funzione IBM Circuit. Questa funzione accetta ",(0,n.jsx)(i.a,{href:"/guides/primitive-input-output",children:"Primitive Unified Blocs"})," (PUB) come input e restituisce valori di aspettazione mitigati dagli errori come output. Fornisce una pipeline automatizzata e personalizzata per ottimizzare i circuiti ed eseguirli su hardware quantistico in modo che i ricercatori possano concentrarsi sulla scoperta di algoritmi e applicazioni."]}),"\n",(0,n.jsxs)(i.p,{children:["Visitate la documentazione per un'",(0,n.jsx)(i.a,{href:"/guides/functions",children:"introduzione alle Qiskit Functions"})," e imparate come iniziare con la ",(0,n.jsx)(i.a,{href:"/guides/ibm-circuit-function",children:"funzione IBM Circuit"}),"."]}),"\n",(0,n.jsx)(i.h2,{id:"background",children:"Contesto"}),"\n",(0,n.jsxs)(i.p,{children:["Questo tutorial considera un circuito generale di evoluzione temporale Trotterizzato hardware-efficient per il modello di Ising a campo trasversale 2D e calcola la magnetizzazione globale. Un tale circuito \xe8 utile in diversi domini applicativi come la fisica della materia condensata, la chimica e l'apprendimento automatico. Per maggiori informazioni sulla struttura di questo modello, consultate ",(0,n.jsx)(i.a,{href:"https://www.nature.com/articles/s41586-023-06096-3",children:"Nature 618, 500\u2013505 (2023)"}),"."]}),"\n",(0,n.jsx)(i.p,{children:"La funzione IBM Circuit combina le capacit\xe0 del servizio transpiler di Qiskit e di Qiskit Runtime Estimator per fornire un'interfaccia semplificata per l'esecuzione dei circuiti. La funzione esegue transpilazione, soppressione degli errori, mitigazione degli errori ed esecuzione del circuito all'interno di un singolo servizio gestito in modo che possiamo concentrarci sulla mappatura del problema ai circuiti piuttosto che sulla costruzione di ogni fase del pattern."}),"\n",(0,n.jsx)(i.h2,{id:"requirements",children:"Requisiti"}),"\n",(0,n.jsx)(i.p,{children:"Prima di iniziare questo tutorial, assicuratevi di avere installato quanto segue:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Qiskit SDK v1.2 o successivo (",(0,n.jsx)(i.code,{children:"pip install qiskit"}),")"]}),"\n",(0,n.jsxs)(i.li,{children:["Qiskit Runtime v0.28 o successivo (",(0,n.jsx)(i.code,{children:"pip install qiskit-ibm-runtime"}),")"]}),"\n",(0,n.jsxs)(i.li,{children:["IBM Qiskit Functions Catalog client v0.0.0 o successivo (",(0,n.jsx)(i.code,{children:"pip install qiskit-ibm-catalog"}),")"]}),"\n",(0,n.jsxs)(i.li,{children:["Qiskit Aer v0.15.0 o successivo (",(0,n.jsx)(i.code,{children:"pip install qiskit-aer"}),")"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"setup",children:"Configurazione"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"import rustworkx\nfrom collections import defaultdict\nfrom numpy import pi, mean\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\nfrom qiskit_ibm_catalog import QiskitFunctionsCatalog\n\nfrom qiskit.circuit import QuantumCircuit, Parameter\nfrom qiskit.quantum_info import SparsePauliOp\n"})}),"\n",(0,n.jsx)(i.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Passo 1: Mappare gli input classici a un problema quantistico"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Input: Parametri per creare il circuito quantistico"}),(0,n.jsx)("li",{children:"Output: Circuito astratto e osservabili"})]}),"\n",(0,n.jsx)(i.h4,{id:"construct-the-circuit",children:"Costruire il circuito"}),"\n",(0,n.jsx)(i.p,{children:"Il circuito che creeremo \xe8 un circuito di evoluzione temporale Trotterizzato hardware-efficient per il modello di Ising a campo trasversale 2D. Iniziamo selezionando un backend. Le propriet\xe0 di questo backend (ovvero, la sua mappa di accoppiamento) saranno utilizzate per definire il problema quantistico e garantire che sia hardware-efficient."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"service = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=127\n)\n"})}),"\n",(0,n.jsx)(i.p,{children:"Successivamente, otteniamo la mappa di accoppiamento dal backend."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"coupling_graph = backend.coupling_map.graph.to_undirected(multigraph=False)\nlayer_couplings = defaultdict(list)\n"})}),"\n",(0,n.jsx)(i.p,{children:"Vogliamo essere attenti nel modo in cui progettiamo i livelli del nostro circuito. Lo faremo colorando i bordi della mappa di accoppiamento (ovvero, raggruppando i bordi disgiunti) e useremo quella colorazione per posizionare i gate nel circuito in modo pi\xf9 efficiente. Questo porter\xe0 a un circuito pi\xf9 superficiale con livelli di gate che possono essere eseguiti simultaneamente sull'hardware."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"edge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)\n\nfor edge_idx, color in edge_coloring.items():\n    layer_couplings[color].append(\n        coupling_graph.get_edge_endpoints_by_index(edge_idx)\n    )\nlayer_couplings = [\n    sorted(layer_couplings[i]) for i in sorted(layer_couplings.keys())\n]\n"})}),"\n",(0,n.jsx)(i.p,{children:"Successivamente, scriviamo una semplice funzione helper che implementa il circuito di evoluzione temporale Trotterizzato hardware-efficient per il modello di Ising a campo trasversale 2D utilizzando la colorazione dei bordi ottenuta sopra."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'def construct_trotter_circuit(\n    num_qubits: int,\n    num_trotter_steps: int,\n    layer_couplings: list,\n    barrier: bool = True,\n) -> QuantumCircuit:\n    theta, phi = Parameter("theta"), Parameter("phi")\n    circuit = QuantumCircuit(num_qubits)\n\n    for _ in range(num_trotter_steps):\n        circuit.rx(theta, range(num_qubits))\n        for layer in layer_couplings:\n            for edge in layer:\n                if edge[0] < num_qubits and edge[1] < num_qubits:\n                    circuit.rzz(phi, edge[0], edge[1])\n        if barrier:\n            circuit.barrier()\n\n    return circuit\n'})}),"\n",(0,n.jsx)(i.p,{children:"Sceglieremo il numero di qubit e passi Trotter e poi costruiremo il circuito."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'num_qubits = 100\nnum_trotter_steps = 2\n\ncircuit = construct_trotter_circuit(\n    num_qubits, num_trotter_steps, layer_couplings\n)\ncircuit.draw("mpl", fold=-1)\n'})}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{alt:"Output of the previous code cell",src:s(73273).A+"",width:"2959",height:"6483"})}),"\n",(0,n.jsxs)(i.p,{children:["Per confrontare la qualit\xe0 dell'esecuzione, dobbiamo confrontarla con il risultato ideale. Il circuito scelto va oltre la simulazione classica a forza bruta. Quindi, fissiamo i parametri di tutti i gate ",(0,n.jsx)(i.code,{children:"Rx"})," nel circuito a ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsx)(i.mn,{children:"0"})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"0"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(i.span,{className:"mord",children:"0"})]})})]}),", e quelli di tutti i gate ",(0,n.jsx)(i.code,{children:"Rzz"})," a ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsx)(i.mi,{children:"\u03c0"})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\pi"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"\u03c0"})]})})]}),". Questo rende il circuito Clifford, il che rende possibile eseguire la simulazione ideale e ottenere il risultato ideale per il confronto. In questo caso, sappiamo che il risultato sar\xe0 ",(0,n.jsx)(i.code,{children:"1.0"}),"."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"parameters = [0, pi]\n"})}),"\n",(0,n.jsx)(i.h4,{id:"construct-the-observable",children:"Costruire l'osservabile"}),"\n",(0,n.jsxs)(i.p,{children:["Prima, calcoliamo la magnetizzazione globale lungo ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.mover,{accent:"true",children:[(0,n.jsx)(i.mi,{children:"z"}),(0,n.jsx)(i.mo,{children:"^"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\hat{z}"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.6944em"}}),(0,n.jsx)(i.span,{className:"mord accent",children:(0,n.jsx)(i.span,{className:"vlist-t",children:(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsxs)(i.span,{className:"vlist",style:{height:"0.6944em"},children:[(0,n.jsxs)(i.span,{style:{top:"-3em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.04398em"},children:"z"})]}),(0,n.jsxs)(i.span,{style:{top:"-3em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(i.span,{className:"accent-body",style:{left:"-0.1944em"},children:(0,n.jsx)(i.span,{className:"mord",children:"^"})})]})]})})})})]})})]})," per il problema a ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsx)(i.mi,{children:"N"})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"N"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.6833em"}}),(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})})]})," qubit: ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsxs)(i.mrow,{children:[(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"M"}),(0,n.jsx)(i.mi,{children:"z"})]}),(0,n.jsx)(i.mo,{children:"="}),(0,n.jsxs)(i.msubsup,{children:[(0,n.jsx)(i.mo,{children:"\u2211"}),(0,n.jsxs)(i.mrow,{children:[(0,n.jsx)(i.mi,{children:"i"}),(0,n.jsx)(i.mo,{children:"="}),(0,n.jsx)(i.mn,{children:"1"})]}),(0,n.jsx)(i.mi,{children:"N"})]}),(0,n.jsx)(i.mo,{stretchy:"false",children:"\u27e8"}),(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"Z"}),(0,n.jsx)(i.mi,{children:"i"})]}),(0,n.jsx)(i.mo,{stretchy:"false",children:"\u27e9"}),(0,n.jsx)(i.mi,{mathvariant:"normal",children:"/"}),(0,n.jsx)(i.mi,{children:"N"})]}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"M_z = \\sum_{i=1}^N \\langle Z_i \\rangle / N"})]})})}),(0,n.jsxs)(i.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"M"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.1514em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.109em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mathnormal mtight",style:{marginRight:"0.04398em"},children:"z"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(i.span,{className:"mrel",children:"="}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"1.2809em",verticalAlign:"-0.2997em"}}),(0,n.jsxs)(i.span,{className:"mop",children:[(0,n.jsx)(i.span,{className:"mop op-symbol small-op",style:{position:"relative",top:"0em"},children:"\u2211"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsxs)(i.span,{className:"vlist",style:{height:"0.9812em"},children:[(0,n.jsxs)(i.span,{style:{top:"-2.4003em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsxs)(i.span,{className:"mord mtight",children:[(0,n.jsx)(i.span,{className:"mord mathnormal mtight",children:"i"}),(0,n.jsx)(i.span,{className:"mrel mtight",children:"="}),(0,n.jsx)(i.span,{className:"mord mtight",children:"1"})]})})]}),(0,n.jsxs)(i.span,{style:{top:"-3.2029em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mathnormal mtight",style:{marginRight:"0.10903em"},children:"N"})})]})]}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.2997em"},children:(0,n.jsx)(i.span,{})})})]})})]}),(0,n.jsx)(i.span,{className:"mopen",children:"\u27e8"}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3117em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mathnormal mtight",children:"i"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]}),(0,n.jsx)(i.span,{className:"mclose",children:"\u27e9"}),(0,n.jsx)(i.span,{className:"mord",children:"/"}),(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})]})]}),". Questo richiede prima di calcolare la magnetizzazione a singolo sito ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsxs)(i.mrow,{children:[(0,n.jsx)(i.mo,{stretchy:"false",children:"\u27e8"}),(0,n.jsxs)(i.msub,{children:[(0,n.jsx)(i.mi,{children:"Z"}),(0,n.jsx)(i.mi,{children:"i"})]}),(0,n.jsx)(i.mo,{stretchy:"false",children:"\u27e9"})]}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\langle Z_i \\rangle"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(i.span,{className:"mopen",children:"\u27e8"}),(0,n.jsxs)(i.span,{className:"mord",children:[(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"}),(0,n.jsx)(i.span,{className:"msupsub",children:(0,n.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(i.span,{className:"vlist-r",children:[(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.3117em"},children:(0,n.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(i.span,{className:"mord mathnormal mtight",children:"i"})})]})}),(0,n.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(i.span,{})})})]})})]}),(0,n.jsx)(i.span,{className:"mclose",children:"\u27e9"})]})})]})," per ogni qubit ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsx)(i.mi,{children:"i"})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.6595em"}}),(0,n.jsx)(i.span,{className:"mord mathnormal",children:"i"})]})})]}),", che \xe8 definita nel codice seguente."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'observables = []\nfor i in range(num_qubits):\n    obs = "I" * (i) + "Z" + "I" * (num_qubits - i - 1)\n    observables.append(SparsePauliOp(obs))\n\nprint(observables[0])\n'})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-text",children:"SparsePauliOp(['ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII'],\n              coeffs=[1.+0.j])\n"})}),"\n",(0,n.jsx)(i.h2,{id:"steps-2-and-3-optimize-problem-for-quantum-hardware-execution-and-execute-with-the-ibm-circuit-function",children:"Passi 2 e 3: Ottimizzare il problema per l'esecuzione su hardware quantistico ed eseguire con la funzione IBM Circuit"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Input: Circuito astratto e osservabili"}),(0,n.jsx)("li",{children:"Output: Valori di aspettazione mitigati"})]}),"\n",(0,n.jsxs)(i.p,{children:["Ora, possiamo passare il circuito astratto e gli osservabili alla funzione IBM Circuit. Essa gestir\xe0 la transpilazione e l'esecuzione su hardware quantistico per noi e restituir\xe0 valori di aspettazione mitigati. Prima, carichiamo la funzione dal ",(0,n.jsx)(i.a,{href:"/guides/functions",children:"IBM Qiskit Functions Catalog"}),"."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'catalog = QiskitFunctionsCatalog(\n    token="<YOUR_API_KEY>"\n)  # Use the 44-character API_KEY you created and saved from the IBM Quantum Platform Home dashboard\nfunction = catalog.load("ibm/circuit-function")\n'})}),"\n",(0,n.jsxs)(i.p,{children:["La funzione IBM Circuit accetta ",(0,n.jsx)(i.code,{children:"pubs"}),", ",(0,n.jsx)(i.code,{children:"backend_name"}),", cos\xec come input opzionali per configurare la transpilazione, la mitigazione degli errori e cos\xec via. Creiamo il ",(0,n.jsx)(i.code,{children:"pub"})," dal circuito astratto, dagli osservabili e dai parametri del circuito. Il nome del backend deve essere specificato come stringa."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"pubs = [(circuit, observables, parameters)]\nbackend_name = backend.name\n"})}),"\n",(0,n.jsxs)(i.p,{children:["Possiamo anche configurare le ",(0,n.jsx)(i.code,{children:"options"})," per la transpilazione, la soppressione degli errori e la mitigazione degli errori. Le impostazioni predefinite verranno utilizzate se non desideriamo specificarle. La funzione IBM Circuit viene fornita con opzioni comunemente utilizzate per ",(0,n.jsx)(i.code,{children:"optimization_level"}),", che controlla quanta ottimizzazione del circuito eseguire, e ",(0,n.jsx)(i.code,{children:"mitigation_level"}),", che specifica quanta soppressione e mitigazione degli errori applicare. Notate che il ",(0,n.jsx)(i.code,{children:"mitigation_level"})," della funzione IBM Circuit \xe8 distinto dal ",(0,n.jsx)(i.code,{children:"resilience_level"})," utilizzato in ",(0,n.jsx)(i.a,{href:"/guides/configure-error-mitigation",children:"Qiskit Runtime Estimator"}),". Per una descrizione dettagliata di queste opzioni comunemente utilizzate cos\xec come di altre opzioni avanzate, visitate la ",(0,n.jsx)(i.a,{href:"/guides/ibm-circuit-function",children:"documentazione per la funzione IBM Circuit"}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["In questo tutorial, imposteremo ",(0,n.jsx)(i.code,{children:"default_precision"}),", ",(0,n.jsx)(i.code,{children:"optimization_level: 3"})," e ",(0,n.jsx)(i.code,{children:"mitigation_level: 3"}),", che attiver\xe0 il gate twirling e la Zero Noise Extrapolation (ZNE) tramite Probabilistic Error Amplification (PEA) oltre alle impostazioni predefinite di livello 1."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'options = {\n    "default_precision": 0.011,\n    "optimization_level": 3,\n    "mitigation_level": 3,\n}\n'})}),"\n",(0,n.jsx)(i.p,{children:"Con gli input specificati, inviamo il job alla funzione IBM Circuit per l'ottimizzazione e l'esecuzione."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"job = function.run(backend_name=backend_name, pubs=pubs, options=options)\n"})}),"\n",(0,n.jsx)(i.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Passo 4: Post-elaborare e restituire il risultato nel formato classico desiderato"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Input: Risultati dalla funzione IBM Circuit"}),(0,n.jsx)("li",{children:"Output: Magnetizzazione globale"})]}),"\n",(0,n.jsx)(i.h4,{id:"compute-the-global-magnetization",children:"Calcolare la magnetizzazione globale"}),"\n",(0,n.jsxs)(i.p,{children:["Il risultato dall'esecuzione della funzione ha lo stesso formato dell'",(0,n.jsx)(i.a,{href:"/guides/primitive-input-output#estimator-output",children:"Estimator"}),"."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"result = job.result()[0]\n"})}),"\n",(0,n.jsxs)(i.p,{children:["Otteniamo i valori di aspettazione mitigati e non mitigati da questo risultato. Questi valori di aspettazione rappresentano la magnetizzazione a singolo sito lungo la direzione ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsx)(i.mrow,{children:(0,n.jsxs)(i.mover,{accent:"true",children:[(0,n.jsx)(i.mi,{children:"z"}),(0,n.jsx)(i.mo,{children:"^"})]})}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"\\hat{z}"})]})})}),(0,n.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.6944em"}}),(0,n.jsx)(i.span,{className:"mord accent",children:(0,n.jsx)(i.span,{className:"vlist-t",children:(0,n.jsx)(i.span,{className:"vlist-r",children:(0,n.jsxs)(i.span,{className:"vlist",style:{height:"0.6944em"},children:[(0,n.jsxs)(i.span,{style:{top:"-3em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.04398em"},children:"z"})]}),(0,n.jsxs)(i.span,{style:{top:"-3em"},children:[(0,n.jsx)(i.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(i.span,{className:"accent-body",style:{left:"-0.1944em"},children:(0,n.jsx)(i.span,{className:"mord",children:"^"})})]})]})})})})]})})]}),". Calcoliamo la media di questi per arrivare alla magnetizzazione globale e confrontare con il valore ideale di ",(0,n.jsx)(i.code,{children:"1.0"})," per questa istanza del problema."]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'mitigated_expvals = result.data.evs\nmagnetization_mitigated = mean(mitigated_expvals)\n\nprint("mitigated:", magnetization_mitigated)\n\nunmitigated_expvals = [\n    result.data.evs_extrapolated[i][0][1] for i in range(num_qubits)\n]\nmagnetization_unmitigated = mean(unmitigated_expvals)\n\nprint("unmitigated:", magnetization_unmitigated)\n'})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-text",children:"mitigated: 0.9749883476088692\nunmitigated: 0.7832977198447583\n"})}),"\n",(0,n.jsx)(i.h2,{id:"tutorial-survey",children:"Sondaggio sul tutorial"}),"\n",(0,n.jsx)(i.p,{children:"Vi preghiamo di rispondere a questo breve sondaggio per fornire feedback su questo tutorial. Le vostre opinioni ci aiuteranno a migliorare i nostri contenuti e l'esperienza utente."}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.a,{href:"https://your.feedback.ibm.com/jfe/form/SV_cCNiGkGX5xZMzoG",children:"Link to survey"})})]})}function d(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}function u(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},73273(e,i,s){s.d(i,{A:()=>a});const a=s.p+"assets/images/18eefa99-f1c4-41b5-90b8-7fd8723cac84-0-1ab0aeb23493a71fed970b92e2f80d86.avif"},28453(e,i,s){s.d(i,{R:()=>r,x:()=>l});var a=s(96540);const n={},t=a.createContext(n);function r(e){const i=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(t.Provider,{value:i},e.children)}}}]);